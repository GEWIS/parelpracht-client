//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/api";
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllCompanies(body: ListParams): Promise<CompanyListResponse> {
        let url_ = this.baseUrl + "/company/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompanies(_response);
        });
    }

    protected processGetAllCompanies(response: Response): Promise<CompanyListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyListResponse>(null as any);
    }

    /**
     * @return Ok
     */
    getCompanySummaries(): Promise<CompanySummary[]> {
        let url_ = this.baseUrl + "/company/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompanySummaries(_response);
        });
    }

    protected processGetCompanySummaries(response: Response): Promise<CompanySummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanySummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanySummary[]>(null as any);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllContractsExtensive(body: ListParams): Promise<ETCompanyListResponse> {
        let url_ = this.baseUrl + "/company/extensive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContractsExtensive(_response);
        });
    }

    protected processGetAllContractsExtensive(response: Response): Promise<ETCompanyListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ETCompanyListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ETCompanyListResponse>(null as any);
    }

    /**
     * @param id ID of company to retrieve
     * @return Ok
     */
    getCompany(id: number): Promise<Company> {
        let url_ = this.baseUrl + "/company/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompany(_response);
        });
    }

    protected processGetCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(null as any);
    }

    /**
     * @param id ID of company to update
     * @param body Update subset of parameter of company
     * @return Ok
     */
    updateCompany(id: number, body: Partial_CompanyParams_): Promise<Company> {
        let url_ = this.baseUrl + "/company/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompany(_response);
        });
    }

    protected processUpdateCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(null as any);
    }

    /**
     * @param id ID of the company to delete
     * @return No content
     */
    deleteCompany(id: number): Promise<void> {
        let url_ = this.baseUrl + "/company/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCompany(_response);
        });
    }

    protected processDeleteCompany(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body Parameters to create company with
     * @return Ok
     */
    createCompany(body: CompanyParams): Promise<Company> {
        let url_ = this.baseUrl + "/company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCompany(_response);
        });
    }

    protected processCreateCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(null as any);
    }

    /**
     * @param id ID of the user
     * @return No content
     */
    uploadCompanyLogo(id: number): Promise<void> {
        let url_ = this.baseUrl + "/company/{id}/logo";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadCompanyLogo(_response);
        });
    }

    protected processUploadCompanyLogo(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id Id of the company
     * @return Ok
     */
    deleteCompanyLogo(id: number): Promise<Company> {
        let url_ = this.baseUrl + "/company/{id}/logo";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCompanyLogo(_response);
        });
    }

    protected processDeleteCompanyLogo(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(null as any);
    }

    /**
     * @param id ID of company to retrieve unresolved invoices for
     * @return Ok
     */
    getUnresolvedInvoices(id: number): Promise<Invoice[]> {
        let url_ = this.baseUrl + "/company/{id}/invoices";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUnresolvedInvoices(_response);
        });
    }

    protected processGetUnresolvedInvoices(response: Response): Promise<Invoice[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Invoice.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Invoice[]>(null as any);
    }

    /**
     * @param id ID of company to retrieve unresolved invoices for
     * @return Ok
     */
    getContacts(id: number): Promise<Contact[]> {
        let url_ = this.baseUrl + "/company/{id}/contacts";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContacts(_response);
        });
    }

    protected processGetContacts(response: Response): Promise<Contact[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Contact.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact[]>(null as any);
    }

    /**
     * @return Ok
     */
    getCompanyStatistics(id: number): Promise<ContractedProductsAnalysis> {
        let url_ = this.baseUrl + "/company/{id}/statistics";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompanyStatistics(_response);
        });
    }

    protected processGetCompanyStatistics(response: Response): Promise<ContractedProductsAnalysis> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractedProductsAnalysis.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractedProductsAnalysis>(null as any);
    }

    /**
     * @param id Id of the company
     * @return Ok
     */
    uploadCompanyFile(id: number): Promise<CompanyFile> {
        let url_ = this.baseUrl + "/company/{id}/file/upload";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadCompanyFile(_response);
        });
    }

    protected processUploadCompanyFile(response: Response): Promise<CompanyFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyFile>(null as any);
    }

    /**
     * @param id ID of the company
     * @param fileId ID of the file
     * @return Ok
     */
    getCompanyFile(id: number, fileId: number): Promise<any> {
        let url_ = this.baseUrl + "/company/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompanyFile(_response);
        });
    }

    protected processGetCompanyFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @param id ID of the company
     * @param fileId ID of the file
     * @param body Update subset of the parameters of the file
     * @return Ok
     */
    updateCompanyFile(id: number, fileId: number, body: Partial_FileParams_): Promise<BaseFile> {
        let url_ = this.baseUrl + "/company/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompanyFile(_response);
        });
    }

    protected processUpdateCompanyFile(response: Response): Promise<BaseFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseFile>(null as any);
    }

    /**
     * @param id ID of the company
     * @param fileId ID of the file
     * @return No content
     */
    deleteCompanyFile(id: number, fileId: number): Promise<void> {
        let url_ = this.baseUrl + "/company/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCompanyFile(_response);
        });
    }

    protected processDeleteCompanyFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of the company
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addCompanyComment(id: number, body: ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/company/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddCompanyComment(_response);
        });
    }

    protected processAddCompanyComment(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the company
     * @param activityId ID of the comment activity
     * @param body Update subset of parameter of comment activity
     * @return Ok
     */
    updateCompanyActivity(id: number, activityId: number, body: Partial_ActivityParams_): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/company/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompanyActivity(_response);
        });
    }

    protected processUpdateCompanyActivity(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the company
     * @param activityId ID of the comment activity
     * @return No content
     */
    deleteCompanyActivity(id: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/company/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCompanyActivity(_response);
        });
    }

    protected processDeleteCompanyActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllContacts(body: ListParams): Promise<ContactListResponse> {
        let url_ = this.baseUrl + "/contact/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContacts(_response);
        });
    }

    protected processGetAllContacts(response: Response): Promise<ContactListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactListResponse>(null as any);
    }

    /**
     * @return Ok
     */
    getContactSummaries(): Promise<ContactSummary[]> {
        let url_ = this.baseUrl + "/contact/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContactSummaries(_response);
        });
    }

    protected processGetContactSummaries(response: Response): Promise<ContactSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactSummary[]>(null as any);
    }

    /**
     * @param id ID of contact to retrieve
     * @return Ok
     */
    getContact(id: number): Promise<Contact> {
        let url_ = this.baseUrl + "/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContact(_response);
        });
    }

    protected processGetContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(null as any);
    }

    /**
     * @param id ID of contact to update
     * @param body Update subset of parameter of contact
     * @return Ok
     */
    updateContact(id: number, body: Partial_ContactParams_): Promise<Contact> {
        let url_ = this.baseUrl + "/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContact(_response);
        });
    }

    protected processUpdateContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(null as any);
    }

    /**
     * @param id ID of the contact
     * @return No content
     */
    deleteContact(id: number): Promise<void> {
        let url_ = this.baseUrl + "/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContact(_response);
        });
    }

    protected processDeleteContact(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body Parameters to create contact with
     * @return Ok
     */
    createContact(body: ContactParams): Promise<Contact> {
        let url_ = this.baseUrl + "/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContact(_response);
        });
    }

    protected processCreateContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(null as any);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllContracts(body: ListParams): Promise<ContractListResponse> {
        let url_ = this.baseUrl + "/contract/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContracts(_response);
        });
    }

    protected processGetAllContracts(response: Response): Promise<ContractListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractListResponse>(null as any);
    }

    /**
     * @return Ok
     */
    getContractSummaries(): Promise<ContractSummary[]> {
        let url_ = this.baseUrl + "/contract/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContractSummaries(_response);
        });
    }

    protected processGetContractSummaries(response: Response): Promise<ContractSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractSummary[]>(null as any);
    }

    /**
     * @return Ok
     */
    getRecentContracts(): Promise<RecentContract[]> {
        let url_ = this.baseUrl + "/contract/recent";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRecentContracts(_response);
        });
    }

    protected processGetRecentContracts(response: Response): Promise<RecentContract[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecentContract.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecentContract[]>(null as any);
    }

    /**
     * @param id ID of contract to retrieve
     * @return Ok
     */
    getContract(id: number): Promise<Contract> {
        let url_ = this.baseUrl + "/contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContract(_response);
        });
    }

    protected processGetContract(response: Response): Promise<Contract> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contract.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contract>(null as any);
    }

    /**
     * @param id ID of contract to update
     * @param body Update subset of parameter of contract
     * @return Ok
     */
    updateContract(id: number, body: Partial_ContractParams_): Promise<Contract> {
        let url_ = this.baseUrl + "/contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContract(_response);
        });
    }

    protected processUpdateContract(response: Response): Promise<Contract> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contract.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contract>(null as any);
    }

    /**
     * @param id ID of the contract
     * @return No content
     */
    deleteContract(id: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContract(_response);
        });
    }

    protected processDeleteContract(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body Parameters to create contract with
     * @return Ok
     */
    createContract(body: ContractParams): Promise<Contract> {
        let url_ = this.baseUrl + "/contract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContract(_response);
        });
    }

    protected processCreateContract(response: Response): Promise<Contract> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contract.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contract>(null as any);
    }

    /**
     * @param id - ID of the contract
     * @param body - Create subset of product
     * @return Ok
     */
    addProductInstanceToContract(id: number, body: ProductInstanceParams): Promise<ProductInstance> {
        let url_ = this.baseUrl + "/contract/{id}/product";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductInstanceToContract(_response);
        });
    }

    protected processAddProductInstanceToContract(response: Response): Promise<ProductInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstance.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstance>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param body Update subset of product instance
     * @return Ok
     */
    updateProductInstanceOnContract(id: number, prodId: number, body: Partial_ProductInstanceParams_): Promise<ProductInstance> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductInstanceOnContract(_response);
        });
    }

    protected processUpdateProductInstanceOnContract(response: Response): Promise<ProductInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstance.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstance>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @return No content
     */
    deleteProductInstance(id: number, prodId: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductInstance(_response);
        });
    }

    protected processDeleteProductInstance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param body Parameters to create this status with
     * @return Ok
     */
    addProductInstanceStatusToContract(id: number, prodId: number, body: ProductInstanceStatusParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductInstanceStatusToContract(_response);
        });
    }

    protected processAddProductInstanceStatusToContract(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addProductInstanceCommentToContract(id: number, prodId: number, body: ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductInstanceCommentToContract(_response);
        });
    }

    protected processAddProductInstanceCommentToContract(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param activityId ID of the activity
     * @param body Update subset of parameter of the activity
     * @return Ok
     */
    updateProductInstanceActivityOnContract(id: number, prodId: number, activityId: number, body: Partial_ActivityParams_): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductInstanceActivityOnContract(_response);
        });
    }

    protected processUpdateProductInstanceActivityOnContract(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param activityId ID of the activity
     * @return No content
     */
    deleteProductInstanceActivityFromContract(id: number, prodId: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductInstanceActivityFromContract(_response);
        });
    }

    protected processDeleteProductInstanceActivityFromContract(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param body Parameters to create this file with
     * @return Ok
     */
    generateContractFile(id: number, body: GenerateContractParams): Promise<any> {
        let url_ = this.baseUrl + "/contract/{id}/file/generate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateContractFile(_response);
        });
    }

    protected processGenerateContractFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @param file The file to upload
     * @param name The name of the new file, as seen in the UI
     * @return Ok
     */
    uploadContractFile(file: FileParameter, name: string): Promise<ContractFile> {
        let url_ = this.baseUrl + "/contract/{id}/file/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("name", name.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadContractFile(_response);
        });
    }

    protected processUploadContractFile(response: Response): Promise<ContractFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractFile>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param fileId ID of the file
     * @return Ok
     */
    getContractFile(id: number, fileId: number): Promise<any> {
        let url_ = this.baseUrl + "/contract/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContractFile(_response);
        });
    }

    protected processGetContractFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param fileId ID of the file
     * @param body Update subset of the parameters of the file
     * @return Ok
     */
    updateContractFile(id: number, fileId: number, body: Partial_FileParams_): Promise<BaseFile> {
        let url_ = this.baseUrl + "/contract/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContractFile(_response);
        });
    }

    protected processUpdateContractFile(response: Response): Promise<BaseFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseFile>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param fileId ID of the file
     * @return No content
     */
    deleteContractFile(id: number, fileId: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContractFile(_response);
        });
    }

    protected processDeleteContractFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param body Parameters to create this status with
     * @return Ok
     */
    addContractStatus(id: number, body: ContractStatusParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddContractStatus(_response);
        });
    }

    protected processAddContractStatus(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addContractComment(id: number, body: ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddContractComment(_response);
        });
    }

    protected processAddContractComment(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param activityId ID of the activity
     * @param body Update subset of parameter of the activity
     * @return Ok
     */
    updateContractActivity(id: number, activityId: number, body: Partial_ActivityParams_): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContractActivity(_response);
        });
    }

    protected processUpdateContractActivity(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the contract
     * @param activityId ID of the activity
     * @return No content
     */
    deleteContractActivity(id: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContractActivity(_response);
        });
    }

    protected processDeleteContractActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllInvoices(body: ListParams): Promise<InvoiceListResponse> {
        let url_ = this.baseUrl + "/invoice/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllInvoices(_response);
        });
    }

    protected processGetAllInvoices(response: Response): Promise<InvoiceListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvoiceListResponse>(null as any);
    }

    /**
     * @return Ok
     */
    getInvoiceSummaries(): Promise<InvoiceSummary[]> {
        let url_ = this.baseUrl + "/invoice/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInvoiceSummaries(_response);
        });
    }

    protected processGetInvoiceSummaries(response: Response): Promise<InvoiceSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvoiceSummary[]>(null as any);
    }

    /**
     * @return Ok
     */
    getExpiredInvoices(): Promise<ExpiredInvoice[]> {
        let url_ = this.baseUrl + "/invoice/expired";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExpiredInvoices(_response);
        });
    }

    protected processGetExpiredInvoices(response: Response): Promise<ExpiredInvoice[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExpiredInvoice.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExpiredInvoice[]>(null as any);
    }

    /**
     * @return No content
     */
    updateLastSeenByTreasurer(): Promise<void> {
        let url_ = this.baseUrl + "/invoice/lastseen";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLastSeenByTreasurer(_response);
        });
    }

    protected processUpdateLastSeenByTreasurer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of invoice to retrieve
     * @return Ok
     */
    getInvoice(id: number): Promise<Invoice> {
        let url_ = this.baseUrl + "/invoice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInvoice(_response);
        });
    }

    protected processGetInvoice(response: Response): Promise<Invoice> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Invoice>(null as any);
    }

    /**
     * @param id ID of invoice to update
     * @param body Update subset of parameter of invoice
     * @return Ok
     */
    updateInvoice(id: number, body: Partial_InvoiceParams_): Promise<Invoice> {
        let url_ = this.baseUrl + "/invoice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateInvoice(_response);
        });
    }

    protected processUpdateInvoice(response: Response): Promise<Invoice> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Invoice>(null as any);
    }

    /**
     * @param id ID of the invoice
     * @return No content
     */
    deleteInvoice(id: number): Promise<void> {
        let url_ = this.baseUrl + "/invoice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteInvoice(_response);
        });
    }

    protected processDeleteInvoice(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body Parameters to create invoice with
     * @return Ok
     */
    createInvoice(body: InvoiceCreateParams): Promise<Invoice> {
        let url_ = this.baseUrl + "/invoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateInvoice(_response);
        });
    }

    protected processCreateInvoice(response: Response): Promise<Invoice> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Invoice>(null as any);
    }

    /**
     * @param id - ID of the invoice
     * @param body - Create subset of product
     * @return Ok
     */
    addProductToInvoice(id: number, body: Body): Promise<ProductInstance> {
        let url_ = this.baseUrl + "/invoice/{id}/product";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductToInvoice(_response);
        });
    }

    protected processAddProductToInvoice(response: Response): Promise<ProductInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstance.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstance>(null as any);
    }

    /**
     * @param id ID of the invoice
     * @param prodId ID of the product instance
     * @return No content
     */
    deleteProductFromInvoice(id: number, prodId: number): Promise<void> {
        let url_ = this.baseUrl + "/invoice/{id}/product/{prodId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductFromInvoice(_response);
        });
    }

    protected processDeleteProductFromInvoice(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of the invoice
     * @param body Parameters to create this file with
     * @return Ok
     */
    generateInvoiceFile(id: number, body: GenerateInvoiceParams): Promise<any> {
        let url_ = this.baseUrl + "/invoice/{id}/file/generate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateInvoiceFile(_response);
        });
    }

    protected processGenerateInvoiceFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @param file The file to upload
     * @param name The name of the new file, as seen in the UI
     * @return Ok
     */
    uploadInvoiceFile(file: FileParameter, name: string): Promise<InvoiceFile> {
        let url_ = this.baseUrl + "/invoice/{id}/file/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("name", name.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadInvoiceFile(_response);
        });
    }

    protected processUploadInvoiceFile(response: Response): Promise<InvoiceFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvoiceFile>(null as any);
    }

    /**
     * @param id ID of the invoice
     * @param fileId ID of the file
     * @return Ok
     */
    getInvoiceFile(id: number, fileId: number): Promise<any> {
        let url_ = this.baseUrl + "/invoice/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInvoiceFile(_response);
        });
    }

    protected processGetInvoiceFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @param id ID of the invoice
     * @param fileId ID of the file
     * @param body Update subset of the parameters of the file
     * @return Ok
     */
    updateInvoiceFile(id: number, fileId: number, body: Partial_FileParams_): Promise<BaseFile> {
        let url_ = this.baseUrl + "/invoice/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateInvoiceFile(_response);
        });
    }

    protected processUpdateInvoiceFile(response: Response): Promise<BaseFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseFile>(null as any);
    }

    /**
     * @param id ID of the invoice
     * @param fileId ID of the file
     * @return No content
     */
    deleteInvoiceFile(id: number, fileId: number): Promise<void> {
        let url_ = this.baseUrl + "/invoice/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteInvoiceFile(_response);
        });
    }

    protected processDeleteInvoiceFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body Parameters to create this custom invoice with
     * @return Ok
     */
    generateCustomInvoice(body: CustomInvoiceGenSettings): Promise<any> {
        let url_ = this.baseUrl + "/invoice/custom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateCustomInvoice(_response);
        });
    }

    protected processGenerateCustomInvoice(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @param id ID of the invoice
     * @param body Parameters to create this status with
     * @return Ok
     */
    addInvoiceStatus(id: number, body: InvoiceStatusParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/invoice/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddInvoiceStatus(_response);
        });
    }

    protected processAddInvoiceStatus(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the invoice
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addInvoiceComment(id: number, body: ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/invoice/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddInvoiceComment(_response);
        });
    }

    protected processAddInvoiceComment(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the invoice
     * @param activityId ID of the activity
     * @param body Update subset of parameter of the activity
     * @return Ok
     */
    updateInvoiceActivity(id: number, activityId: number, body: Partial_ActivityParams_): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/invoice/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateInvoiceActivity(_response);
        });
    }

    protected processUpdateInvoiceActivity(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllCategories(body: ListParams): Promise<CategoryListResponse> {
        let url_ = this.baseUrl + "/category/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCategories(_response);
        });
    }

    protected processGetAllCategories(response: Response): Promise<CategoryListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryListResponse>(null as any);
    }

    /**
     * @return Ok
     */
    getCategorySummaries(): Promise<CategorySummary[]> {
        let url_ = this.baseUrl + "/category/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategorySummaries(_response);
        });
    }

    protected processGetCategorySummaries(response: Response): Promise<CategorySummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategorySummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategorySummary[]>(null as any);
    }

    /**
     * @param body Parameters to create category with
     * @return Ok
     */
    createCategory(body: CategoryParams): Promise<ProductCategory> {
        let url_ = this.baseUrl + "/category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: Response): Promise<ProductCategory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategory.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductCategory>(null as any);
    }

    /**
     * @param id ID of the category
     * @return Ok
     */
    getCategory(id: number): Promise<ProductCategory> {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategory(_response);
        });
    }

    protected processGetCategory(response: Response): Promise<ProductCategory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategory.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductCategory>(null as any);
    }

    /**
     * @param id ID of the category
     * @param body Update subset of parameter of category
     * @return Ok
     */
    updateCategory(id: number, body: Partial_CategoryParams_): Promise<ProductCategory> {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCategory(_response);
        });
    }

    protected processUpdateCategory(response: Response): Promise<ProductCategory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategory.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductCategory>(null as any);
    }

    /**
     * @param id ID of the category
     * @return No content
     */
    deleteCategory(id: number): Promise<void> {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param year Financial year of the overview
     * @return Ok
     */
    getContractedProductsStatistics(year: number): Promise<ContractedProductsAnalysis> {
        let url_ = this.baseUrl + "/category/stats/contracted/{year}";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined.");
        url_ = url_.replace("{year}", encodeURIComponent("" + year));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContractedProductsStatistics(_response);
        });
    }

    protected processGetContractedProductsStatistics(response: Response): Promise<ContractedProductsAnalysis> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractedProductsAnalysis.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractedProductsAnalysis>(null as any);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllProducts(body: ListParams): Promise<ProductListResponse> {
        let url_ = this.baseUrl + "/product/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProducts(_response);
        });
    }

    protected processGetAllProducts(response: Response): Promise<ProductListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductListResponse>(null as any);
    }

    /**
     * @return Ok
     */
    getProductSummaries(): Promise<ProductSummary[]> {
        let url_ = this.baseUrl + "/product/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductSummaries(_response);
        });
    }

    protected processGetProductSummaries(response: Response): Promise<ProductSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductSummary[]>(null as any);
    }

    /**
     * @param id ID of product to retrieve
     * @return Ok
     */
    getProduct(id: number): Promise<Product> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProduct(_response);
        });
    }

    protected processGetProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(null as any);
    }

    /**
     * @param id ID of product to update
     * @param body Update subset of parameter of product
     * @return Ok
     */
    updateProduct(id: number, body: Partial_ProductParams_): Promise<Product> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProduct(_response);
        });
    }

    protected processUpdateProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(null as any);
    }

    /**
     * @param id ID of the product
     * @return No content
     */
    deleteProduct(id: number): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProduct(_response);
        });
    }

    protected processDeleteProduct(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body Parameters to create product with
     * @return Ok
     */
    createProduct(body: ProductParams): Promise<Product> {
        let url_ = this.baseUrl + "/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProduct(_response);
        });
    }

    protected processCreateProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(null as any);
    }

    /**
     * @param id ID of the product
     * @return Ok
     */
    addPricing(id: number): Promise<ProductPricing> {
        let url_ = this.baseUrl + "/product/{id}/pricing";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddPricing(_response);
        });
    }

    protected processAddPricing(response: Response): Promise<ProductPricing> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPricing.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductPricing>(null as any);
    }

    /**
     * @param id ID of the product
     * @param body Description string and JSON table (nested array)
     * @return Ok
     */
    updatePricing(id: number, body: Partial_PricingParams_): Promise<ProductPricing> {
        let url_ = this.baseUrl + "/product/{id}/pricing";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePricing(_response);
        });
    }

    protected processUpdatePricing(response: Response): Promise<ProductPricing> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPricing.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductPricing>(null as any);
    }

    /**
     * @param id ID of the product
     * @return No content
     */
    deletePricing(id: number): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}/pricing";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePricing(_response);
        });
    }

    protected processDeletePricing(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id Product id
     * @param body Skip and take to allow for pagination
     * @return Ok
     */
    getProductContracts(id: number, body: PaginationParams): Promise<ProductInstanceListResponse> {
        let url_ = this.baseUrl + "/product/{id}/contracts";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductContracts(_response);
        });
    }

    protected processGetProductContracts(response: Response): Promise<ProductInstanceListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstanceListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstanceListResponse>(null as any);
    }

    /**
     * @param id Product id
     * @param body Skip and take to allow for pagination
     * @return Ok
     */
    getProductInvoices(id: number, body: PaginationParams): Promise<ProductInstanceListResponse> {
        let url_ = this.baseUrl + "/product/{id}/invoices";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductInvoices(_response);
        });
    }

    protected processGetProductInvoices(response: Response): Promise<ProductInstanceListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstanceListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstanceListResponse>(null as any);
    }

    /**
     * @return Ok
     */
    getProductStatistics(id: number): Promise<AnalysisResultByYear[]> {
        let url_ = this.baseUrl + "/product/{id}/statistics";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductStatistics(_response);
        });
    }

    protected processGetProductStatistics(response: Response): Promise<AnalysisResultByYear[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AnalysisResultByYear.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalysisResultByYear[]>(null as any);
    }

    /**
     * @param file The file to upload
     * @param name The name of the new file, as seen in the UI
     * @return Ok
     */
    uploadProductFile(file: FileParameter, name: string): Promise<ProductFile> {
        let url_ = this.baseUrl + "/product/{id}/file/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("name", name.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadProductFile(_response);
        });
    }

    protected processUploadProductFile(response: Response): Promise<ProductFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductFile>(null as any);
    }

    /**
     * @param id ID of the product
     * @param fileId ID of the file
     * @return Ok
     */
    getProductFile(id: number, fileId: number): Promise<any> {
        let url_ = this.baseUrl + "/product/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductFile(_response);
        });
    }

    protected processGetProductFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @param id ID of the product
     * @param fileId ID of the file
     * @param body Update subset of the parameters of the file
     * @return Ok
     */
    updateProductFile(id: number, fileId: number, body: Partial_FileParams_): Promise<BaseFile> {
        let url_ = this.baseUrl + "/product/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductFile(_response);
        });
    }

    protected processUpdateProductFile(response: Response): Promise<BaseFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseFile>(null as any);
    }

    /**
     * @param id ID of the product
     * @param fileId ID of the file
     * @return No content
     */
    deleteProductFile(id: number, fileId: number): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductFile(_response);
        });
    }

    protected processDeleteProductFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of the product
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addProductComment(id: number, body: ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/product/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductComment(_response);
        });
    }

    protected processAddProductComment(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the product
     * @param activityId ID of the activity
     * @param body Update subset of parameter of comment activity
     * @return Ok
     */
    updateProductActivity(id: number, activityId: number, body: Partial_ActivityParams_): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/product/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductActivity(_response);
        });
    }

    protected processUpdateProductActivity(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(null as any);
    }

    /**
     * @param id ID of the product
     * @param activityId ID of the activity
     * @return No content
     */
    deleteProductActivity(id: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductActivity(_response);
        });
    }

    protected processDeleteProductActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param year Financial year of the overview
     * @return Ok
     */
    getDashboardProductInstanceStatistics(year: number): Promise<DashboardProductInstanceStats> {
        let url_ = this.baseUrl + "/product/stats/statuses/{year}";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined.");
        url_ = url_.replace("{year}", encodeURIComponent("" + year));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDashboardProductInstanceStatistics(_response);
        });
    }

    protected processGetDashboardProductInstanceStatistics(response: Response): Promise<DashboardProductInstanceStats> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardProductInstanceStats.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardProductInstanceStats>(null as any);
    }

    /**
     * @return Ok
     */
    getAllRoles(): Promise<Role[]> {
        let url_ = this.baseUrl + "/role";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRoles(_response);
        });
    }

    protected processGetAllRoles(response: Response): Promise<Role[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role[]>(null as any);
    }

    /**
     * @return Ok
     */
    getRole(id: string): Promise<Role> {
        let url_ = this.baseUrl + "/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRole(_response);
        });
    }

    protected processGetRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * @return Ok
     */
    updateRole(id: string, body: Partial_RoleParams_): Promise<Role> {
        let url_ = this.baseUrl + "/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(null as any);
    }

    /**
     * @return No content
     */
    postSetup(body: SetupParams): Promise<void> {
        let url_ = this.baseUrl + "/setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostSetup(_response);
        });
    }

    protected processPostSetup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getAuthStatus(): Promise<AuthStatus> {
        let url_ = this.baseUrl + "/authStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAuthStatus(_response);
        });
    }

    protected processGetAuthStatus(response: Response): Promise<AuthStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthStatus>(null as any);
    }

    /**
     * @return Ok
     */
    getProfile(): Promise<Profile> {
        let url_ = this.baseUrl + "/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfile(_response);
        });
    }

    protected processGetProfile(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Profile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile>(null as any);
    }

    /**
     * @return No content
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No content
     */
    forgotPassword(email: string): Promise<void> {
        let url_ = this.baseUrl + "/forgotPassword?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No content
     */
    resetPassword(body: ResetPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    generateApiKey(): Promise<string> {
        let url_ = this.baseUrl + "/generateApiKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateApiKey(_response);
        });
    }

    protected processGenerateApiKey(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Ok
     */
    getApiKey(): Promise<string> {
        let url_ = this.baseUrl + "/getApiKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApiKey(_response);
        });
    }

    protected processGetApiKey(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return No content
     */
    revokeApiKey(): Promise<void> {
        let url_ = this.baseUrl + "/revokeApiKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRevokeApiKey(_response);
        });
    }

    protected processRevokeApiKey(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    getPrivateGeneralInfo(): Promise<GeneralPrivateInfo> {
        let url_ = this.baseUrl + "/getPrivateGeneralInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPrivateGeneralInfo(_response);
        });
    }

    protected processGetPrivateGeneralInfo(response: Response): Promise<GeneralPrivateInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralPrivateInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GeneralPrivateInfo>(null as any);
    }

    /**
     * @return Ok
     */
    getPublicGeneralInfo(): Promise<GeneralPublicInfo> {
        let url_ = this.baseUrl + "/getPublicGeneralInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicGeneralInfo(_response);
        });
    }

    protected processGetPublicGeneralInfo(response: Response): Promise<GeneralPublicInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralPublicInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GeneralPublicInfo>(null as any);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllUsers(body: ListParams): Promise<UserListResponse> {
        let url_ = this.baseUrl + "/user/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUsers(_response);
        });
    }

    protected processGetAllUsers(response: Response): Promise<UserListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserListResponse>(null as any);
    }

    /**
     * @return Ok
     */
    getUserSummaries(): Promise<UserSummary[]> {
        let url_ = this.baseUrl + "/user/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserSummaries(_response);
        });
    }

    protected processGetUserSummaries(response: Response): Promise<UserSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSummary[]>(null as any);
    }

    /**
     * @param id ID of user to retrieve
     * @return Ok
     */
    getUser(id: number): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param id ID of user to delete
     * @return No content
     */
    deleteUser(id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = WrappedApiError.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of user to update
     * @param body Update subset of parameter of user
     * @return Ok
     */
    updateUser(id: number, body: Partial_UserParams_): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param body Parameters to create user with
     * @return Ok
     */
    createUser(body: UserParams): Promise<User> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param id ID of the user
     * @return No content
     */
    uploadUserAvatar(id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/{id}/logo";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadUserAvatar(_response);
        });
    }

    protected processUploadUserAvatar(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of the user
     * @return Ok
     */
    deleteUserAvatar(id: number): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}/logo";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUserAvatar(_response);
        });
    }

    protected processDeleteUserAvatar(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param id ID of the user
     * @return No content
     */
    uploadUserBackground(id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/{id}/background";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadUserBackground(_response);
        });
    }

    protected processUploadUserBackground(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id ID of the user
     * @return Ok
     */
    deleteUserBackground(id: number): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}/background";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUserBackground(_response);
        });
    }

    protected processDeleteUserBackground(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param id ID of the from-user
     * @param body parameters, namely ID of the to-user
     * @return No content
     */
    transferAssignments(id: number, body: TransferUserParams): Promise<void> {
        let url_ = this.baseUrl + "/user/{id}/assignments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTransferAssignments(_response);
        });
    }

    protected processTransferAssignments(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    createLocalIdentity(id: number): Promise<IdentityLocal> {
        let url_ = this.baseUrl + "/user/{id}/auth/local";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLocalIdentity(_response);
        });
    }

    protected processCreateLocalIdentity(response: Response): Promise<IdentityLocal> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityLocal.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityLocal>(null as any);
    }

    /**
     * @return No content
     */
    deleteLocalIdentity(id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/{id}/auth/local";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteLocalIdentity(_response);
        });
    }

    protected processDeleteLocalIdentity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    createLdapIdentity(id: number, body: LdapIdentityParams): Promise<IdentityLDAP> {
        let url_ = this.baseUrl + "/user/{id}/auth/ldap";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLdapIdentity(_response);
        });
    }

    protected processCreateLdapIdentity(response: Response): Promise<IdentityLDAP> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityLDAP.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityLDAP>(null as any);
    }

    /**
     * @return Ok
     */
    updateLdapIdentity(id: number, body: Partial_LdapIdentityParams_): Promise<IdentityLDAP> {
        let url_ = this.baseUrl + "/user/{id}/auth/ldap";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLdapIdentity(_response);
        });
    }

    protected processUpdateLdapIdentity(response: Response): Promise<IdentityLDAP> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityLDAP.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityLDAP>(null as any);
    }

    /**
     * @return No content
     */
    deleteLdapIdentity(id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/{id}/auth/ldap";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteLdapIdentity(_response);
        });
    }

    protected processDeleteLdapIdentity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllVAT(body: ListParams): Promise<VATListResponse> {
        let url_ = this.baseUrl + "/VAT/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllVAT(_response);
        });
    }

    protected processGetAllVAT(response: Response): Promise<VATListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VATListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VATListResponse>(null as any);
    }

    /**
     * @return Ok
     */
    getVATSummaries(): Promise<VATSummary[]> {
        let url_ = this.baseUrl + "/VAT/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVATSummaries(_response);
        });
    }

    protected processGetVATSummaries(response: Response): Promise<VATSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VATSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VATSummary[]>(null as any);
    }

    /**
     * @param id ID of the VAT
     * @return Ok
     */
    getVAT(id: number): Promise<ValueAddedTax> {
        let url_ = this.baseUrl + "/VAT/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVAT(_response);
        });
    }

    protected processGetVAT(response: Response): Promise<ValueAddedTax> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValueAddedTax.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValueAddedTax>(null as any);
    }

    /**
     * @param id ID of the VAT
     * @param body Update subset of parameter of VAT
     * @return Ok
     */
    updateVAT(id: number, body: Partial_VATParams_): Promise<ValueAddedTax> {
        let url_ = this.baseUrl + "/VAT/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateVAT(_response);
        });
    }

    protected processUpdateVAT(response: Response): Promise<ValueAddedTax> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValueAddedTax.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValueAddedTax>(null as any);
    }

    /**
     * @return Ok
     */
    login(body: LoginParams): Promise<void> {
        let url_ = this.baseUrl + "/login/local";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Ok
     */
    loginLDAP(body: LDAPLoginParams): Promise<void> {
        let url_ = this.baseUrl + "/login/ldap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLoginLDAP(_response);
        });
    }

    protected processLoginLDAP(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export enum CompanyStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
}

export class Company implements ICompany {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Name of the company */
    name!: string;
    addressStreet!: string;
    addressPostalCode!: string;
    addressCity!: string;
    addressCountry!: string;
    invoiceAddressStreet!: string;
    invoiceAddressPostalCode!: string;
    invoiceAddressCity!: string;
    invoiceAddressCountry!: string;
    /** Status of the collaboration with this company */
    status!: CompanyStatus;
    /** General phone number of the company */
    phoneNumber?: string;
    /** Optional filename of a logo image */
    logoFilename!: string;
    /** Comments regarding the company */
    comments?: string;
    /** All contracts related to this company */
    contracts!: Contract[];
    /** All invoices related to this company */
    invoices!: Invoice[];
    /** All contact persons related to this company */
    contacts!: Contact[];
    /** All updates / activities regarding this company */
    activities!: CompanyActivity[];
    /** All files regarding this company */
    files!: CompanyFile[];

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contracts = [];
            this.invoices = [];
            this.contacts = [];
            this.activities = [];
            this.files = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.addressStreet = _data["addressStreet"];
            this.addressPostalCode = _data["addressPostalCode"];
            this.addressCity = _data["addressCity"];
            this.addressCountry = _data["addressCountry"];
            this.invoiceAddressStreet = _data["invoiceAddressStreet"];
            this.invoiceAddressPostalCode = _data["invoiceAddressPostalCode"];
            this.invoiceAddressCity = _data["invoiceAddressCity"];
            this.invoiceAddressCountry = _data["invoiceAddressCountry"];
            this.status = _data["status"];
            this.phoneNumber = _data["phoneNumber"];
            this.logoFilename = _data["logoFilename"];
            this.comments = _data["comments"];
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts!.push(Contract.fromJS(item));
            }
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices!.push(Invoice.fromJS(item));
            }
            if (Array.isArray(_data["contacts"])) {
                this.contacts = [] as any;
                for (let item of _data["contacts"])
                    this.contacts!.push(Contact.fromJS(item));
            }
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(CompanyActivity.fromJS(item));
            }
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(CompanyFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["addressStreet"] = this.addressStreet;
        data["addressPostalCode"] = this.addressPostalCode;
        data["addressCity"] = this.addressCity;
        data["addressCountry"] = this.addressCountry;
        data["invoiceAddressStreet"] = this.invoiceAddressStreet;
        data["invoiceAddressPostalCode"] = this.invoiceAddressPostalCode;
        data["invoiceAddressCity"] = this.invoiceAddressCity;
        data["invoiceAddressCountry"] = this.invoiceAddressCountry;
        data["status"] = this.status;
        data["phoneNumber"] = this.phoneNumber;
        data["logoFilename"] = this.logoFilename;
        data["comments"] = this.comments;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        if (Array.isArray(this.contacts)) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICompany {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Name of the company */
    name: string;
    addressStreet: string;
    addressPostalCode: string;
    addressCity: string;
    addressCountry: string;
    invoiceAddressStreet: string;
    invoiceAddressPostalCode: string;
    invoiceAddressCity: string;
    invoiceAddressCountry: string;
    /** Status of the collaboration with this company */
    status: CompanyStatus;
    /** General phone number of the company */
    phoneNumber?: string;
    /** Optional filename of a logo image */
    logoFilename: string;
    /** Comments regarding the company */
    comments?: string;
    /** All contracts related to this company */
    contracts: Contract[];
    /** All invoices related to this company */
    invoices: Invoice[];
    /** All contact persons related to this company */
    contacts: Contact[];
    /** All updates / activities regarding this company */
    activities: CompanyActivity[];
    /** All files regarding this company */
    files: CompanyFile[];
}

export enum ProductStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
}

export enum VAT {
    ZERO = "ZERO",
    LOW = "LOW",
    HIGH = "HIGH",
}

export class Product implements IProduct {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Dutch name of the product */
    nameDutch!: string;
    /** English name of the product */
    nameEnglish!: string;
    /** Price is stored * 100 and as integer */
    targetPrice!: number;
    /** Status of the collaboration with this company */
    status!: ProductStatus;
    /** Description of the product, only used within the application */
    description!: string;
    /** Text that should be used on generated PDF files, in Dutch */
    contractTextDutch!: string;
    /** Text that should be used on generated PDF files, in English */
    contractTextEnglish!: string;
    /** Delivery attachment text used on the PDF file, in Dutch */
    deliverySpecificationDutch?: string;
    /** Delivery attachment text used on the PDF file, in English */
    deliverySpecificationEnglish?: string;
    vatId!: number;
    categoryId!: number;
    /** Target minimum amount contracted for this product */
    minTarget!: number;
    /** Target maximum amount contracted for this product */
    maxTarget!: number;
    /** VAT category this product is in */
    valueAddedTax!: ValueAddedTax;
    /** Category this product is in */
    category!: ProductCategory;
    /** All the product instances of this product, used in contracts and invoiced */
    instances!: ProductInstance[];
    /** All activities regarding this product */
    activities!: ProductActivity[];
    /** All files regarding this product */
    files!: ProductFile[];
    /** Optional ProductPricing object */
    pricing?: ProductPricing;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.valueAddedTax = new ValueAddedTax();
            this.category = new ProductCategory();
            this.instances = [];
            this.activities = [];
            this.files = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.contractTextDutch = _data["contractTextDutch"];
            this.contractTextEnglish = _data["contractTextEnglish"];
            this.deliverySpecificationDutch = _data["deliverySpecificationDutch"];
            this.deliverySpecificationEnglish = _data["deliverySpecificationEnglish"];
            this.vatId = _data["vatId"];
            this.categoryId = _data["categoryId"];
            this.minTarget = _data["minTarget"];
            this.maxTarget = _data["maxTarget"];
            this.valueAddedTax = _data["valueAddedTax"] ? ValueAddedTax.fromJS(_data["valueAddedTax"]) : new ValueAddedTax();
            this.category = _data["category"] ? ProductCategory.fromJS(_data["category"]) : new ProductCategory();
            if (Array.isArray(_data["instances"])) {
                this.instances = [] as any;
                for (let item of _data["instances"])
                    this.instances!.push(ProductInstance.fromJS(item));
            }
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(ProductActivity.fromJS(item));
            }
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ProductFile.fromJS(item));
            }
            this.pricing = _data["pricing"] ? ProductPricing.fromJS(_data["pricing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        data["status"] = this.status;
        data["description"] = this.description;
        data["contractTextDutch"] = this.contractTextDutch;
        data["contractTextEnglish"] = this.contractTextEnglish;
        data["deliverySpecificationDutch"] = this.deliverySpecificationDutch;
        data["deliverySpecificationEnglish"] = this.deliverySpecificationEnglish;
        data["vatId"] = this.vatId;
        data["categoryId"] = this.categoryId;
        data["minTarget"] = this.minTarget;
        data["maxTarget"] = this.maxTarget;
        data["valueAddedTax"] = this.valueAddedTax ? this.valueAddedTax.toJSON() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.instances)) {
            data["instances"] = [];
            for (let item of this.instances)
                data["instances"].push(item.toJSON());
        }
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["pricing"] = this.pricing ? this.pricing.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProduct {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Dutch name of the product */
    nameDutch: string;
    /** English name of the product */
    nameEnglish: string;
    /** Price is stored * 100 and as integer */
    targetPrice: number;
    /** Status of the collaboration with this company */
    status: ProductStatus;
    /** Description of the product, only used within the application */
    description: string;
    /** Text that should be used on generated PDF files, in Dutch */
    contractTextDutch: string;
    /** Text that should be used on generated PDF files, in English */
    contractTextEnglish: string;
    /** Delivery attachment text used on the PDF file, in Dutch */
    deliverySpecificationDutch?: string;
    /** Delivery attachment text used on the PDF file, in English */
    deliverySpecificationEnglish?: string;
    vatId: number;
    categoryId: number;
    /** Target minimum amount contracted for this product */
    minTarget: number;
    /** Target maximum amount contracted for this product */
    maxTarget: number;
    /** VAT category this product is in */
    valueAddedTax: ValueAddedTax;
    /** Category this product is in */
    category: ProductCategory;
    /** All the product instances of this product, used in contracts and invoiced */
    instances: ProductInstance[];
    /** All activities regarding this product */
    activities: ProductActivity[];
    /** All files regarding this product */
    files: ProductFile[];
    /** Optional ProductPricing object */
    pricing?: ProductPricing;
}

export class ValueAddedTax implements IValueAddedTax {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** VAT category */
    category!: VAT;
    /** Price is stored * 100 and as integer */
    amount!: number;
    /** All products in this category */
    products!: Product[];

    constructor(data?: IValueAddedTax) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.products = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.category = _data["category"];
            this.amount = _data["amount"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValueAddedTax {
        data = typeof data === 'object' ? data : {};
        let result = new ValueAddedTax();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["category"] = this.category;
        data["amount"] = this.amount;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IValueAddedTax {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** VAT category */
    category: VAT;
    /** Price is stored * 100 and as integer */
    amount: number;
    /** All products in this category */
    products: Product[];
}

export class ProductCategory implements IProductCategory {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Name of the product category */
    name!: string;
    /** All products in this category */
    products!: Product[];

    constructor(data?: IProductCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.products = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductCategory {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Name of the product category */
    name: string;
    /** All products in this category */
    products: Product[];
}

export class ProductInstance implements IProductInstance {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    productId!: number;
    /** The ID of the product, this entity is instanced from */
    product!: Product;
    contractId!: number;
    /** Contract this product is used in */
    contract!: Contract;
    invoiceId?: number;
    /** Invoice this product is used in, if it has already been invoiced */
    invoice?: Invoice;
    /** All activities regarding this product instance */
    activities!: ProductInstanceActivity[];
    /** Actual price of the product, should be a copy from the product price upon creation,
or a different price that is not a discount
price is excluding VAT */
    basePrice!: number;
    /** Optional discount amount, discount is taken over excl. VAT price */
    discount!: number;
    /** Any comments regarding this product instance */
    details?: string;

    constructor(data?: IProductInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.product = new Product();
            this.contract = new Contract();
            this.activities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : new Product();
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? Contract.fromJS(_data["contract"]) : new Contract();
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : <any>undefined;
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(ProductInstanceActivity.fromJS(item));
            }
            this.basePrice = _data["basePrice"];
            this.discount = _data["discount"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): ProductInstance {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        data["basePrice"] = this.basePrice;
        data["discount"] = this.discount;
        data["details"] = this.details;
        return data;
    }
}

export interface IProductInstance {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    productId: number;
    /** The ID of the product, this entity is instanced from */
    product: Product;
    contractId: number;
    /** Contract this product is used in */
    contract: Contract;
    invoiceId?: number;
    /** Invoice this product is used in, if it has already been invoiced */
    invoice?: Invoice;
    /** All activities regarding this product instance */
    activities: ProductInstanceActivity[];
    /** Actual price of the product, should be a copy from the product price upon creation,
or a different price that is not a discount
price is excluding VAT */
    basePrice: number;
    /** Optional discount amount, discount is taken over excl. VAT price */
    discount: number;
    /** Any comments regarding this product instance */
    details?: string;
}

export enum ActivityType {
    STATUS = "STATUS",
    COMMENT = "COMMENT",
    EDIT = "EDIT",
    REASSIGN = "REASSIGN",
    ADDPRODUCT = "ADDPRODUCT",
    DELPRODUCT = "DELPRODUCT",
}

export enum Gender {
    MALE = "MALE",
    FEMALE = "FEMALE",
    OTHER = "OTHER",
    UNKNOWN = "UNKNOWN",
}

export class User implements IUser {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Gender of this user */
    gender!: Gender;
    /** First name of this user */
    firstName!: string;
    /** Middle name of this user, if he/she has any */
    lastNamePreposition!: string;
    /** Last name of this user */
    lastName!: string;
    /** Email address of the user */
    email!: string;
    /** Email address used in PDF files */
    replyToEmail!: string;
    /** Any comments regarding this user */
    comment!: string;
    /** Function of this user, used when generating documents and printed below this user's name */
    function!: string;
    /** Optional filename of the user's avatar */
    avatarFilename!: string;
    /** Optional filename of the user's background */
    backgroundFilename!: string;
    /** Whether this user wishes to receive (regular) email updates, e.g. sent invoices */
    receiveEmails!: boolean;
    /** Whether the update emails (from the boolean above) should
be sent to "email", or "replyToEmail" */
    sendEmailsToReplyToEmail!: boolean;
    /** The roles this user has */
    roles!: Role[];
    /** Identity for local login */
    identityLocal?: IdentityLocal;
    /** Identity for LDAP */
    identityLdap?: IdentityLDAP;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.replyToEmail = _data["replyToEmail"];
            this.comment = _data["comment"];
            this.function = _data["function"];
            this.avatarFilename = _data["avatarFilename"];
            this.backgroundFilename = _data["backgroundFilename"];
            this.receiveEmails = _data["receiveEmails"];
            this.sendEmailsToReplyToEmail = _data["sendEmailsToReplyToEmail"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
            this.identityLocal = _data["identityLocal"] ? IdentityLocal.fromJS(_data["identityLocal"]) : <any>undefined;
            this.identityLdap = _data["identityLdap"] ? IdentityLDAP.fromJS(_data["identityLdap"]) : <any>undefined;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["replyToEmail"] = this.replyToEmail;
        data["comment"] = this.comment;
        data["function"] = this.function;
        data["avatarFilename"] = this.avatarFilename;
        data["backgroundFilename"] = this.backgroundFilename;
        data["receiveEmails"] = this.receiveEmails;
        data["sendEmailsToReplyToEmail"] = this.sendEmailsToReplyToEmail;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["identityLocal"] = this.identityLocal ? this.identityLocal.toJSON() : <any>undefined;
        data["identityLdap"] = this.identityLdap ? this.identityLdap.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUser {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Gender of this user */
    gender: Gender;
    /** First name of this user */
    firstName: string;
    /** Middle name of this user, if he/she has any */
    lastNamePreposition: string;
    /** Last name of this user */
    lastName: string;
    /** Email address of the user */
    email: string;
    /** Email address used in PDF files */
    replyToEmail: string;
    /** Any comments regarding this user */
    comment: string;
    /** Function of this user, used when generating documents and printed below this user's name */
    function: string;
    /** Optional filename of the user's avatar */
    avatarFilename: string;
    /** Optional filename of the user's background */
    backgroundFilename: string;
    /** Whether this user wishes to receive (regular) email updates, e.g. sent invoices */
    receiveEmails: boolean;
    /** Whether the update emails (from the boolean above) should
be sent to "email", or "replyToEmail" */
    sendEmailsToReplyToEmail: boolean;
    /** The roles this user has */
    roles: Role[];
    /** Identity for local login */
    identityLocal?: IdentityLocal;
    /** Identity for LDAP */
    identityLdap?: IdentityLDAP;
}

export class Role implements IRole {
    /** Name of the role */
    name!: string;
    /** LDAP group used for this role */
    ldapGroup!: string;
    /** All users having this role */
    users!: User[];

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.users = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.ldapGroup = _data["ldapGroup"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["ldapGroup"] = this.ldapGroup;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRole {
    /** Name of the role */
    name: string;
    /** LDAP group used for this role */
    ldapGroup: string;
    /** All users having this role */
    users: User[];
}

export class IdentityLocal implements IIdentityLocal {
    /** ID of the associated user */
    id!: number;
    verifiedEmail!: boolean;
    salt?: string;
    hash?: string;
    lastLogin?: Date;
    user!: User;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date
at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;

    constructor(data?: IIdentityLocal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.verifiedEmail = _data["verifiedEmail"];
            this.salt = _data["salt"];
            this.hash = _data["hash"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): IdentityLocal {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityLocal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["verifiedEmail"] = this.verifiedEmail;
        data["salt"] = this.salt;
        data["hash"] = this.hash;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export interface IIdentityLocal {
    /** ID of the associated user */
    id: number;
    verifiedEmail: boolean;
    salt?: string;
    hash?: string;
    lastLogin?: Date;
    user: User;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date
at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
}

export class IdentityLDAP implements IIdentityLDAP {
    /** ID of the associated user */
    id!: number;
    username!: string;
    overrideEmail!: boolean;
    lastLogin?: Date;
    user!: User;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date
at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;

    constructor(data?: IIdentityLDAP) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.overrideEmail = _data["overrideEmail"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): IdentityLDAP {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityLDAP();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["overrideEmail"] = this.overrideEmail;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export interface IIdentityLDAP {
    /** ID of the associated user */
    id: number;
    username: string;
    overrideEmail: boolean;
    lastLogin?: Date;
    user: User;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date
at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
}

export class ProductActivity implements IProductActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish!: string;
    /** Description of this activity (Dutch) */
    descriptionDutch!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;
    productId!: number;
    /** Product related to this activity */
    product!: Product;

    constructor(data?: IProductActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.product = new Product();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.descriptionEnglish = _data["descriptionEnglish"];
            this.descriptionDutch = _data["descriptionDutch"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : new Product();
        }
    }

    static fromJS(data: any): ProductActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ProductActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["descriptionEnglish"] = this.descriptionEnglish;
        data["descriptionDutch"] = this.descriptionDutch;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish: string;
    /** Description of this activity (Dutch) */
    descriptionDutch: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
    productId: number;
    /** Product related to this activity */
    product: Product;
}

export class ProductFile implements IProductFile {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Label of the file as shown in the front-end */
    name!: string;
    /** Name of the file as shown when downloaded */
    downloadName!: string;
    /** Location of the file on disk */
    location!: string;
    createdById!: number;
    /** User who created this file */
    createdBy!: User;
    productId!: number;
    /** Invoice related to this file */
    product!: Product;

    constructor(data?: IProductFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.product = new Product();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.downloadName = _data["downloadName"];
            this.location = _data["location"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : new Product();
        }
    }

    static fromJS(data: any): ProductFile {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["downloadName"] = this.downloadName;
        data["location"] = this.location;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductFile {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Label of the file as shown in the front-end */
    name: string;
    /** Name of the file as shown when downloaded */
    downloadName: string;
    /** Location of the file on disk */
    location: string;
    createdById: number;
    /** User who created this file */
    createdBy: User;
    productId: number;
    /** Invoice related to this file */
    product: Product;
}

export class ProductPricing implements IProductPricing {
    id!: number;
    /** Piece of text to be placed above the table */
    description!: string;
    /** Table parsed as a JSON object */
    data!: string[][];
    product!: Product;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date
at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;

    constructor(data?: IProductPricing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
            this.product = new Product();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : new Product();
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ProductPricing {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPricing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        return data;
    }
}

export interface IProductPricing {
    id: number;
    /** Piece of text to be placed above the table */
    description: string;
    /** Table parsed as a JSON object */
    data: string[][];
    product: Product;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date
at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
}

export class Contract implements IContract {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Title or name of this contract/collaboration */
    title!: string;
    companyId!: number;
    /** Company this contract has been closed with */
    company!: Company;
    /** All products in the contract */
    products!: ProductInstance[];
    createdById!: number;
    createdBy!: User;
    assignedToId!: number;
    assignedTo!: User;
    contactId!: number;
    /** Comments regarding this contract, if there are any */
    comments?: string;
    /** The contact this contract has been closed with */
    contact!: Contact;
    /** All activities regarding this contract */
    activities!: ContractActivity[];
    /** All files regarding this contract */
    files!: ContractFile[];

    constructor(data?: IContract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.company = new Company();
            this.products = [];
            this.createdBy = new User();
            this.assignedTo = new User();
            this.contact = new Contact();
            this.activities = [];
            this.files = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductInstance.fromJS(item));
            }
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.assignedToId = _data["assignedToId"];
            this.assignedTo = _data["assignedTo"] ? User.fromJS(_data["assignedTo"]) : new User();
            this.contactId = _data["contactId"];
            this.comments = _data["comments"];
            this.contact = _data["contact"] ? Contact.fromJS(_data["contact"]) : new Contact();
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(ContractActivity.fromJS(item));
            }
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ContractFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Contract {
        data = typeof data === 'object' ? data : {};
        let result = new Contract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["assignedToId"] = this.assignedToId;
        data["assignedTo"] = this.assignedTo ? this.assignedTo.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["comments"] = this.comments;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContract {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Title or name of this contract/collaboration */
    title: string;
    companyId: number;
    /** Company this contract has been closed with */
    company: Company;
    /** All products in the contract */
    products: ProductInstance[];
    createdById: number;
    createdBy: User;
    assignedToId: number;
    assignedTo: User;
    contactId: number;
    /** Comments regarding this contract, if there are any */
    comments?: string;
    /** The contact this contract has been closed with */
    contact: Contact;
    /** All activities regarding this contract */
    activities: ContractActivity[];
    /** All files regarding this contract */
    files: ContractFile[];
}

export class Invoice implements IInvoice {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** All products that have been invoiced */
    products!: ProductInstance[];
    /** Name of the invoice (by default the same as the first contract) */
    title!: string;
    /** PO number on the invoice, if needed */
    poNumber?: string;
    /** Date at which this invoice will be sent */
    startDate!: Date;
    companyId!: number;
    createdById!: number;
    createdBy!: User;
    assignedToId!: number;
    assignedTo!: User;
    /** Any comments regarding this invoice */
    comments?: string;
    /** Company this invoice is directed to */
    company!: Company;
    /** All activities regarding this invoice */
    activities!: InvoiceActivity[];
    /** All files regarding this contract */
    files!: InvoiceFile[];

    constructor(data?: IInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.products = [];
            this.createdBy = new User();
            this.assignedTo = new User();
            this.company = new Company();
            this.activities = [];
            this.files = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductInstance.fromJS(item));
            }
            this.title = _data["title"];
            this.poNumber = _data["poNumber"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.assignedToId = _data["assignedToId"];
            this.assignedTo = _data["assignedTo"] ? User.fromJS(_data["assignedTo"]) : new User();
            this.comments = _data["comments"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(InvoiceActivity.fromJS(item));
            }
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(InvoiceFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["poNumber"] = this.poNumber;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["assignedToId"] = this.assignedToId;
        data["assignedTo"] = this.assignedTo ? this.assignedTo.toJSON() : <any>undefined;
        data["comments"] = this.comments;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInvoice {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** All products that have been invoiced */
    products: ProductInstance[];
    /** Name of the invoice (by default the same as the first contract) */
    title: string;
    /** PO number on the invoice, if needed */
    poNumber?: string;
    /** Date at which this invoice will be sent */
    startDate: Date;
    companyId: number;
    createdById: number;
    createdBy: User;
    assignedToId: number;
    assignedTo: User;
    /** Any comments regarding this invoice */
    comments?: string;
    /** Company this invoice is directed to */
    company: Company;
    /** All activities regarding this invoice */
    activities: InvoiceActivity[];
    /** All files regarding this contract */
    files: InvoiceFile[];
}

export enum InvoiceStatus {
    CREATED = "CREATED",
    PROPOSED = "PROPOSED",
    SENT = "SENT",
    PAID = "PAID",
    IRRECOVERABLE = "IRRECOVERABLE",
    CANCELLED = "CANCELLED",
}

export class InvoiceActivity implements IInvoiceActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish!: string;
    /** Description of this activity (Dutch) */
    descriptionDutch!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;
    invoiceId!: number;
    /** Invoice related to this activity */
    invoice!: Invoice;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: InvoiceStatus;

    constructor(data?: IInvoiceActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.invoice = new Invoice();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.descriptionEnglish = _data["descriptionEnglish"];
            this.descriptionDutch = _data["descriptionDutch"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : new Invoice();
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): InvoiceActivity {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["descriptionEnglish"] = this.descriptionEnglish;
        data["descriptionDutch"] = this.descriptionDutch;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["subType"] = this.subType;
        return data;
    }
}

export interface IInvoiceActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish: string;
    /** Description of this activity (Dutch) */
    descriptionDutch: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
    invoiceId: number;
    /** Invoice related to this activity */
    invoice: Invoice;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: InvoiceStatus;
}

export class InvoiceFile implements IInvoiceFile {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Label of the file as shown in the front-end */
    name!: string;
    /** Name of the file as shown when downloaded */
    downloadName!: string;
    /** Location of the file on disk */
    location!: string;
    createdById!: number;
    /** User who created this file */
    createdBy!: User;
    invoiceId!: number;
    /** Invoice related to this file */
    invoice!: Invoice;

    constructor(data?: IInvoiceFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.invoice = new Invoice();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.downloadName = _data["downloadName"];
            this.location = _data["location"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : new Invoice();
        }
    }

    static fromJS(data: any): InvoiceFile {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["downloadName"] = this.downloadName;
        data["location"] = this.location;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInvoiceFile {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Label of the file as shown in the front-end */
    name: string;
    /** Name of the file as shown when downloaded */
    downloadName: string;
    /** Location of the file on disk */
    location: string;
    createdById: number;
    /** User who created this file */
    createdBy: User;
    invoiceId: number;
    /** Invoice related to this file */
    invoice: Invoice;
}

export enum ProductInstanceStatus {
    NOTDELIVERED = "NOTDELIVERED",
    DELIVERED = "DELIVERED",
    CANCELLED = "CANCELLED",
    DEFERRED = "DEFERRED",
}

export class ProductInstanceActivity implements IProductInstanceActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish!: string;
    /** Description of this activity (Dutch) */
    descriptionDutch!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;
    productInstanceId!: number;
    /** ProductInstance related to this activity */
    productInstance!: ProductInstance;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: ProductInstanceStatus;

    constructor(data?: IProductInstanceActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.productInstance = new ProductInstance();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.descriptionEnglish = _data["descriptionEnglish"];
            this.descriptionDutch = _data["descriptionDutch"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.productInstanceId = _data["productInstanceId"];
            this.productInstance = _data["productInstance"] ? ProductInstance.fromJS(_data["productInstance"]) : new ProductInstance();
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): ProductInstanceActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstanceActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["descriptionEnglish"] = this.descriptionEnglish;
        data["descriptionDutch"] = this.descriptionDutch;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["productInstanceId"] = this.productInstanceId;
        data["productInstance"] = this.productInstance ? this.productInstance.toJSON() : <any>undefined;
        data["subType"] = this.subType;
        return data;
    }
}

export interface IProductInstanceActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish: string;
    /** Description of this activity (Dutch) */
    descriptionDutch: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
    productInstanceId: number;
    /** ProductInstance related to this activity */
    productInstance: ProductInstance;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: ProductInstanceStatus;
}

export enum ContactFunction {
    NORMAL = "NORMAL",
    PRIMARY = "PRIMARY",
    FINANCIAL = "FINANCIAL",
    OLD = "OLD",
}

export class Contact implements IContact {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** The gender of this contact */
    gender!: Gender;
    /** The first name of the contact */
    firstName!: string;
    /** The middle name of the contact, if he/she has one */
    lastNamePreposition!: string;
    /** The last name of the contact */
    lastName!: string;
    /** The (personal) email address of the contact */
    email!: string;
    /** The (personal) phone number of the contact */
    telephone!: string;
    /** Comments regarding the contact person, if there are any */
    comments!: string;
    /** Function of this contact person within the company, if known. Normal by default. */
    function!: ContactFunction;
    companyId!: number;
    /** Company this contact person works at */
    company!: Company;
    /** All contracts that have been closed with this contact person */
    contracts!: Contract[];

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.company = new Company();
            this.contracts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.comments = _data["comments"];
            this.function = _data["function"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts!.push(Contract.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["comments"] = this.comments;
        data["function"] = this.function;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContact {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** The gender of this contact */
    gender: Gender;
    /** The first name of the contact */
    firstName: string;
    /** The middle name of the contact, if he/she has one */
    lastNamePreposition: string;
    /** The last name of the contact */
    lastName: string;
    /** The (personal) email address of the contact */
    email: string;
    /** The (personal) phone number of the contact */
    telephone: string;
    /** Comments regarding the contact person, if there are any */
    comments: string;
    /** Function of this contact person within the company, if known. Normal by default. */
    function: ContactFunction;
    companyId: number;
    /** Company this contact person works at */
    company: Company;
    /** All contracts that have been closed with this contact person */
    contracts: Contract[];
}

export enum ContractStatus {
    CREATED = "CREATED",
    PROPOSED = "PROPOSED",
    SENT = "SENT",
    CONFIRMED = "CONFIRMED",
    FINISHED = "FINISHED",
    CANCELLED = "CANCELLED",
}

export class ContractActivity implements IContractActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish!: string;
    /** Description of this activity (Dutch) */
    descriptionDutch!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;
    contractId!: number;
    /** Contract related to this activity */
    contract!: Contract;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: ContractStatus;

    constructor(data?: IContractActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.contract = new Contract();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.descriptionEnglish = _data["descriptionEnglish"];
            this.descriptionDutch = _data["descriptionDutch"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? Contract.fromJS(_data["contract"]) : new Contract();
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): ContractActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ContractActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["descriptionEnglish"] = this.descriptionEnglish;
        data["descriptionDutch"] = this.descriptionDutch;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["subType"] = this.subType;
        return data;
    }
}

export interface IContractActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish: string;
    /** Description of this activity (Dutch) */
    descriptionDutch: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
    contractId: number;
    /** Contract related to this activity */
    contract: Contract;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: ContractStatus;
}

export class ContractFile implements IContractFile {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Label of the file as shown in the front-end */
    name!: string;
    /** Name of the file as shown when downloaded */
    downloadName!: string;
    /** Location of the file on disk */
    location!: string;
    createdById!: number;
    /** User who created this file */
    createdBy!: User;
    contractId!: number;
    /** Contract related to this file */
    contract!: Contract;

    constructor(data?: IContractFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.contract = new Contract();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.downloadName = _data["downloadName"];
            this.location = _data["location"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? Contract.fromJS(_data["contract"]) : new Contract();
        }
    }

    static fromJS(data: any): ContractFile {
        data = typeof data === 'object' ? data : {};
        let result = new ContractFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["downloadName"] = this.downloadName;
        data["location"] = this.location;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContractFile {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Label of the file as shown in the front-end */
    name: string;
    /** Name of the file as shown when downloaded */
    downloadName: string;
    /** Location of the file on disk */
    location: string;
    createdById: number;
    /** User who created this file */
    createdBy: User;
    contractId: number;
    /** Contract related to this file */
    contract: Contract;
}

export class CompanyActivity implements ICompanyActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish!: string;
    /** Description of this activity (Dutch) */
    descriptionDutch!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;
    companyId!: number;
    /** Company related to this activity */
    company!: Company;

    constructor(data?: ICompanyActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.company = new Company();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.descriptionEnglish = _data["descriptionEnglish"];
            this.descriptionDutch = _data["descriptionDutch"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
        }
    }

    static fromJS(data: any): CompanyActivity {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["descriptionEnglish"] = this.descriptionEnglish;
        data["descriptionDutch"] = this.descriptionDutch;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompanyActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish: string;
    /** Description of this activity (Dutch) */
    descriptionDutch: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
    companyId: number;
    /** Company related to this activity */
    company: Company;
}

export class CompanyFile implements ICompanyFile {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Label of the file as shown in the front-end */
    name!: string;
    /** Name of the file as shown when downloaded */
    downloadName!: string;
    /** Location of the file on disk */
    location!: string;
    createdById!: number;
    /** User who created this file */
    createdBy!: User;
    companyId!: number;
    /** Company related to this file */
    company!: Company;

    constructor(data?: ICompanyFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.company = new Company();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.downloadName = _data["downloadName"];
            this.location = _data["location"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
        }
    }

    static fromJS(data: any): CompanyFile {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["downloadName"] = this.downloadName;
        data["location"] = this.location;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompanyFile {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Label of the file as shown in the front-end */
    name: string;
    /** Name of the file as shown when downloaded */
    downloadName: string;
    /** Location of the file on disk */
    location: string;
    createdById: number;
    /** User who created this file */
    createdBy: User;
    companyId: number;
    /** Company related to this file */
    company: Company;
}

export class CompanyListResponse implements ICompanyListResponse {
    list!: Company[];
    count!: number;

    constructor(data?: ICompanyListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Company.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): CompanyListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface ICompanyListResponse {
    list: Company[];
    count: number;
}

export class ApiError implements IApiError {
    name!: string;
    message!: string;
    stack?: string;
    /** The activity code of the error, as defined by HTTP activity codes. */
    statusCode!: number;

    constructor(data?: IApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.message = _data["message"];
            this.stack = _data["stack"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): ApiError {
        data = typeof data === 'object' ? data : {};
        let result = new ApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["message"] = this.message;
        data["stack"] = this.stack;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IApiError {
    name: string;
    message: string;
    stack?: string;
    /** The activity code of the error, as defined by HTTP activity codes. */
    statusCode: number;
}

/** WrappedApiError represents the type returned by the server. */
export class WrappedApiError implements IWrappedApiError {
    error!: ApiError;

    [key: string]: any;

    constructor(data?: IWrappedApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.error = new ApiError();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.error = _data["error"] ? ApiError.fromJS(_data["error"]) : new ApiError();
        }
    }

    static fromJS(data: any): WrappedApiError {
        data = typeof data === 'object' ? data : {};
        let result = new WrappedApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

/** WrappedApiError represents the type returned by the server. */
export interface IWrappedApiError {
    error: ApiError;

    [key: string]: any;
}

export enum SortDirection {
    ASC = "ASC",
    DESC = "DESC",
}

export class ListSorting implements IListSorting {
    column!: string;
    direction!: SortDirection;

    constructor(data?: IListSorting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["column"];
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): ListSorting {
        data = typeof data === 'object' ? data : {};
        let result = new ListSorting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["column"] = this.column;
        data["direction"] = this.direction;
        return data;
    }
}

export interface IListSorting {
    column: string;
    direction: SortDirection;
}

export class ListOrFilter implements IListOrFilter {
    column!: string;
    values!: any[];

    constructor(data?: IListOrFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.values = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["column"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): ListOrFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ListOrFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["column"] = this.column;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

export interface IListOrFilter {
    column: string;
    values: any[];
}

export class ListParams implements IListParams {
    skip?: number;
    take?: number;
    sorting?: ListSorting;
    search?: string;
    filters?: ListOrFilter[];

    constructor(data?: IListParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skip = _data["skip"];
            this.take = _data["take"];
            this.sorting = _data["sorting"] ? ListSorting.fromJS(_data["sorting"]) : <any>undefined;
            this.search = _data["search"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(ListOrFilter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListParams {
        data = typeof data === 'object' ? data : {};
        let result = new ListParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip;
        data["take"] = this.take;
        data["sorting"] = this.sorting ? this.sorting.toJSON() : <any>undefined;
        data["search"] = this.search;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListParams {
    skip?: number;
    take?: number;
    sorting?: ListSorting;
    search?: string;
    filters?: ListOrFilter[];
}

export class CompanySummary implements ICompanySummary {
    id!: number;
    name!: string;
    logoFilename!: string;
    status!: CompanyStatus;

    constructor(data?: ICompanySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.logoFilename = _data["logoFilename"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CompanySummary {
        data = typeof data === 'object' ? data : {};
        let result = new CompanySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["logoFilename"] = this.logoFilename;
        data["status"] = this.status;
        return data;
    }
}

export interface ICompanySummary {
    id: number;
    name: string;
    logoFilename: string;
    status: CompanyStatus;
}

export class ETProductInstance implements IETProductInstance {
    id!: number;
    productId!: number;
    details?: string;
    basePrice!: number;
    discount!: number;
    subType!: ProductInstanceStatus;
    invoiceDate?: Date;

    constructor(data?: IETProductInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.details = _data["details"];
            this.basePrice = _data["basePrice"];
            this.discount = _data["discount"];
            this.subType = _data["subType"];
            this.invoiceDate = _data["invoiceDate"] ? new Date(_data["invoiceDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ETProductInstance {
        data = typeof data === 'object' ? data : {};
        let result = new ETProductInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["details"] = this.details;
        data["basePrice"] = this.basePrice;
        data["discount"] = this.discount;
        data["subType"] = this.subType;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IETProductInstance {
    id: number;
    productId: number;
    details?: string;
    basePrice: number;
    discount: number;
    subType: ProductInstanceStatus;
    invoiceDate?: Date;
}

export class ETContract implements IETContract {
    id!: number;
    title!: string;
    subType!: ContractStatus;
    products!: ETProductInstance[];

    constructor(data?: IETContract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.products = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.subType = _data["subType"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ETProductInstance.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ETContract {
        data = typeof data === 'object' ? data : {};
        let result = new ETContract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["subType"] = this.subType;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IETContract {
    id: number;
    title: string;
    subType: ContractStatus;
    products: ETProductInstance[];
}

export class ETCompany implements IETCompany {
    id!: number;
    name!: string;
    contracts!: ETContract[];

    constructor(data?: IETCompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contracts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts!.push(ETContract.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ETCompany {
        data = typeof data === 'object' ? data : {};
        let result = new ETCompany();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IETCompany {
    id: number;
    name: string;
    contracts: ETContract[];
}

export class ETCompanyListResponse implements IETCompanyListResponse {
    list!: ETCompany[];
    count!: number;
    extra!: Extra;

    constructor(data?: IETCompanyListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
            this.extra = new Extra();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(ETCompany.fromJS(item));
            }
            this.count = _data["count"];
            this.extra = _data["extra"] ? Extra.fromJS(_data["extra"]) : new Extra();
        }
    }

    static fromJS(data: any): ETCompanyListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ETCompanyListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["extra"] = this.extra ? this.extra.toJSON() : <any>undefined;
        return data;
    }
}

export interface IETCompanyListResponse {
    list: ETCompany[];
    count: number;
    extra: Extra;
}

export class CompanyParams implements ICompanyParams {
    name!: string;
    comments?: string;
    phoneNumber?: string;
    addressStreet!: string;
    addressPostalCode!: string;
    addressCity!: string;
    addressCountry!: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;

    constructor(data?: ICompanyParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.comments = _data["comments"];
            this.phoneNumber = _data["phoneNumber"];
            this.addressStreet = _data["addressStreet"];
            this.addressPostalCode = _data["addressPostalCode"];
            this.addressCity = _data["addressCity"];
            this.addressCountry = _data["addressCountry"];
            this.invoiceAddressStreet = _data["invoiceAddressStreet"];
            this.invoiceAddressPostalCode = _data["invoiceAddressPostalCode"];
            this.invoiceAddressCity = _data["invoiceAddressCity"];
            this.invoiceAddressCountry = _data["invoiceAddressCountry"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CompanyParams {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["comments"] = this.comments;
        data["phoneNumber"] = this.phoneNumber;
        data["addressStreet"] = this.addressStreet;
        data["addressPostalCode"] = this.addressPostalCode;
        data["addressCity"] = this.addressCity;
        data["addressCountry"] = this.addressCountry;
        data["invoiceAddressStreet"] = this.invoiceAddressStreet;
        data["invoiceAddressPostalCode"] = this.invoiceAddressPostalCode;
        data["invoiceAddressCity"] = this.invoiceAddressCity;
        data["invoiceAddressCountry"] = this.invoiceAddressCountry;
        data["status"] = this.status;
        return data;
    }
}

export interface ICompanyParams {
    name: string;
    comments?: string;
    phoneNumber?: string;
    addressStreet: string;
    addressPostalCode: string;
    addressCity: string;
    addressCountry: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;
}

/** Make all properties in T optional */
export class Partial_CompanyParams_ implements IPartial_CompanyParams_ {
    name?: string;
    comments?: string;
    phoneNumber?: string;
    addressStreet?: string;
    addressPostalCode?: string;
    addressCity?: string;
    addressCountry?: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;

    [key: string]: any;

    constructor(data?: IPartial_CompanyParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.comments = _data["comments"];
            this.phoneNumber = _data["phoneNumber"];
            this.addressStreet = _data["addressStreet"];
            this.addressPostalCode = _data["addressPostalCode"];
            this.addressCity = _data["addressCity"];
            this.addressCountry = _data["addressCountry"];
            this.invoiceAddressStreet = _data["invoiceAddressStreet"];
            this.invoiceAddressPostalCode = _data["invoiceAddressPostalCode"];
            this.invoiceAddressCity = _data["invoiceAddressCity"];
            this.invoiceAddressCountry = _data["invoiceAddressCountry"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Partial_CompanyParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_CompanyParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["comments"] = this.comments;
        data["phoneNumber"] = this.phoneNumber;
        data["addressStreet"] = this.addressStreet;
        data["addressPostalCode"] = this.addressPostalCode;
        data["addressCity"] = this.addressCity;
        data["addressCountry"] = this.addressCountry;
        data["invoiceAddressStreet"] = this.invoiceAddressStreet;
        data["invoiceAddressPostalCode"] = this.invoiceAddressPostalCode;
        data["invoiceAddressCity"] = this.invoiceAddressCity;
        data["invoiceAddressCountry"] = this.invoiceAddressCountry;
        data["status"] = this.status;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_CompanyParams_ {
    name?: string;
    comments?: string;
    phoneNumber?: string;
    addressStreet?: string;
    addressPostalCode?: string;
    addressCity?: string;
    addressCountry?: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;

    [key: string]: any;
}

export class ProductsPerCategory implements IProductsPerCategory {
    categoryId!: number;
    amount!: number[];
    nrOfProducts!: number[];

    constructor(data?: IProductsPerCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.amount = [];
            this.nrOfProducts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["amount"])) {
                this.amount = [] as any;
                for (let item of _data["amount"])
                    this.amount!.push(item);
            }
            if (Array.isArray(_data["nrOfProducts"])) {
                this.nrOfProducts = [] as any;
                for (let item of _data["nrOfProducts"])
                    this.nrOfProducts!.push(item);
            }
        }
    }

    static fromJS(data: any): ProductsPerCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductsPerCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.amount)) {
            data["amount"] = [];
            for (let item of this.amount)
                data["amount"].push(item);
        }
        if (Array.isArray(this.nrOfProducts)) {
            data["nrOfProducts"] = [];
            for (let item of this.nrOfProducts)
                data["nrOfProducts"].push(item);
        }
        return data;
    }
}

export interface IProductsPerCategory {
    categoryId: number;
    amount: number[];
    nrOfProducts: number[];
}

export class ContractedProductsAnalysis implements IContractedProductsAnalysis {
    categories!: ProductsPerCategory[];
    labels?: string[];
    financialYears?: number[];

    constructor(data?: IContractedProductsAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.categories = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(ProductsPerCategory.fromJS(item));
            }
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["financialYears"])) {
                this.financialYears = [] as any;
                for (let item of _data["financialYears"])
                    this.financialYears!.push(item);
            }
        }
    }

    static fromJS(data: any): ContractedProductsAnalysis {
        data = typeof data === 'object' ? data : {};
        let result = new ContractedProductsAnalysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.financialYears)) {
            data["financialYears"] = [];
            for (let item of this.financialYears)
                data["financialYears"].push(item);
        }
        return data;
    }
}

export interface IContractedProductsAnalysis {
    categories: ProductsPerCategory[];
    labels?: string[];
    financialYears?: number[];
}

export class BaseFile implements IBaseFile {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Label of the file as shown in the front-end */
    name!: string;
    /** Name of the file as shown when downloaded */
    downloadName!: string;
    /** Location of the file on disk */
    location!: string;
    createdById!: number;
    /** User who created this file */
    createdBy!: User;

    constructor(data?: IBaseFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.downloadName = _data["downloadName"];
            this.location = _data["location"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
        }
    }

    static fromJS(data: any): BaseFile {
        data = typeof data === 'object' ? data : {};
        let result = new BaseFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["downloadName"] = this.downloadName;
        data["location"] = this.location;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBaseFile {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Label of the file as shown in the front-end */
    name: string;
    /** Name of the file as shown when downloaded */
    downloadName: string;
    /** Location of the file on disk */
    location: string;
    createdById: number;
    /** User who created this file */
    createdBy: User;
}

/** Make all properties in T optional */
export class Partial_FileParams_ implements IPartial_FileParams_ {
    name?: string;
    createdAt?: Date;

    [key: string]: any;

    constructor(data?: IPartial_FileParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Partial_FileParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_FileParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_FileParams_ {
    name?: string;
    createdAt?: Date;

    [key: string]: any;
}

export class BaseActivity implements IBaseActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish!: string;
    /** Description of this activity (Dutch) */
    descriptionDutch!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;

    constructor(data?: IBaseActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.descriptionEnglish = _data["descriptionEnglish"];
            this.descriptionDutch = _data["descriptionDutch"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
        }
    }

    static fromJS(data: any): BaseActivity {
        data = typeof data === 'object' ? data : {};
        let result = new BaseActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["descriptionEnglish"] = this.descriptionEnglish;
        data["descriptionDutch"] = this.descriptionDutch;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBaseActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity (English) */
    descriptionEnglish: string;
    /** Description of this activity (Dutch) */
    descriptionDutch: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
}

export class ActivityParams implements IActivityParams {
    description!: string;

    constructor(data?: IActivityParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ActivityParams {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data;
    }
}

export interface IActivityParams {
    description: string;
}

/** Make all properties in T optional */
export class Partial_ActivityParams_ implements IPartial_ActivityParams_ {
    description?: string;

    [key: string]: any;

    constructor(data?: IPartial_ActivityParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Partial_ActivityParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ActivityParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_ActivityParams_ {
    description?: string;

    [key: string]: any;
}

export class ContactListResponse implements IContactListResponse {
    list!: Contact[];
    count!: number;

    constructor(data?: IContactListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Contact.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ContactListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IContactListResponse {
    list: Contact[];
    count: number;
}

export class ContactSummary implements IContactSummary {
    id!: number;
    firstName!: string;
    lastNamePreposition!: string;
    lastName!: string;
    companyId!: number;
    function!: ContactFunction;

    constructor(data?: IContactSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.companyId = _data["companyId"];
            this.function = _data["function"];
        }
    }

    static fromJS(data: any): ContactSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["companyId"] = this.companyId;
        data["function"] = this.function;
        return data;
    }
}

export interface IContactSummary {
    id: number;
    firstName: string;
    lastNamePreposition: string;
    lastName: string;
    companyId: number;
    function: ContactFunction;
}

export class ContactParams implements IContactParams {
    gender!: Gender;
    firstName?: string;
    lastNamePreposition?: string;
    lastName!: string;
    email!: string;
    telephone?: string;
    comments?: string;
    companyId!: number;
    function!: ContactFunction;

    constructor(data?: IContactParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.comments = _data["comments"];
            this.companyId = _data["companyId"];
            this.function = _data["function"];
        }
    }

    static fromJS(data: any): ContactParams {
        data = typeof data === 'object' ? data : {};
        let result = new ContactParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["comments"] = this.comments;
        data["companyId"] = this.companyId;
        data["function"] = this.function;
        return data;
    }
}

export interface IContactParams {
    gender: Gender;
    firstName?: string;
    lastNamePreposition?: string;
    lastName: string;
    email: string;
    telephone?: string;
    comments?: string;
    companyId: number;
    function: ContactFunction;
}

/** Make all properties in T optional */
export class Partial_ContactParams_ implements IPartial_ContactParams_ {
    gender?: Gender;
    firstName?: string;
    lastNamePreposition?: string;
    lastName?: string;
    email?: string;
    telephone?: string;
    comments?: string;
    companyId?: number;
    function?: ContactFunction;

    [key: string]: any;

    constructor(data?: IPartial_ContactParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.comments = _data["comments"];
            this.companyId = _data["companyId"];
            this.function = _data["function"];
        }
    }

    static fromJS(data: any): Partial_ContactParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ContactParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["comments"] = this.comments;
        data["companyId"] = this.companyId;
        data["function"] = this.function;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_ContactParams_ {
    gender?: Gender;
    firstName?: string;
    lastNamePreposition?: string;
    lastName?: string;
    email?: string;
    telephone?: string;
    comments?: string;
    companyId?: number;
    function?: ContactFunction;

    [key: string]: any;
}

export class ContractListResponse implements IContractListResponse {
    list!: Contract[];
    count!: number;

    constructor(data?: IContractListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Contract.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ContractListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContractListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IContractListResponse {
    list: Contract[];
    count: number;
}

export class ContractSummary implements IContractSummary {
    id!: number;
    title!: string;
    value!: number;
    status!: ContractStatus;

    constructor(data?: IContractSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.value = _data["value"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ContractSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["value"] = this.value;
        data["status"] = this.status;
        return data;
    }
}

export interface IContractSummary {
    id: number;
    title: string;
    value: number;
    status: ContractStatus;
}

export class RecentContract implements IRecentContract {
    id!: number;
    title!: string;
    companyId!: number;
    assignedToId!: number;
    contactId!: number;
    createdAt!: Date;
    updatedAt!: Date;
    type!: ActivityType;
    description!: string;
    createdById!: number;
    subType!: ContractStatus;

    constructor(data?: IRecentContract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.assignedToId = _data["assignedToId"];
            this.contactId = _data["contactId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.description = _data["description"];
            this.createdById = _data["createdById"];
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): RecentContract {
        data = typeof data === 'object' ? data : {};
        let result = new RecentContract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["assignedToId"] = this.assignedToId;
        data["contactId"] = this.contactId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["description"] = this.description;
        data["createdById"] = this.createdById;
        data["subType"] = this.subType;
        return data;
    }
}

export interface IRecentContract {
    id: number;
    title: string;
    companyId: number;
    assignedToId: number;
    contactId: number;
    createdAt: Date;
    updatedAt: Date;
    type: ActivityType;
    description: string;
    createdById: number;
    subType: ContractStatus;
}

export class ContractParams implements IContractParams {
    title!: string;
    companyId!: number;
    contactId!: number;
    comments?: string;
    assignedToId?: number;

    constructor(data?: IContractParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.contactId = _data["contactId"];
            this.comments = _data["comments"];
            this.assignedToId = _data["assignedToId"];
        }
    }

    static fromJS(data: any): ContractParams {
        data = typeof data === 'object' ? data : {};
        let result = new ContractParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["contactId"] = this.contactId;
        data["comments"] = this.comments;
        data["assignedToId"] = this.assignedToId;
        return data;
    }
}

export interface IContractParams {
    title: string;
    companyId: number;
    contactId: number;
    comments?: string;
    assignedToId?: number;
}

/** Make all properties in T optional */
export class Partial_ContractParams_ implements IPartial_ContractParams_ {
    title?: string;
    companyId?: number;
    contactId?: number;
    comments?: string;
    assignedToId?: number;

    [key: string]: any;

    constructor(data?: IPartial_ContractParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.contactId = _data["contactId"];
            this.comments = _data["comments"];
            this.assignedToId = _data["assignedToId"];
        }
    }

    static fromJS(data: any): Partial_ContractParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ContractParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["contactId"] = this.contactId;
        data["comments"] = this.comments;
        data["assignedToId"] = this.assignedToId;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_ContractParams_ {
    title?: string;
    companyId?: number;
    contactId?: number;
    comments?: string;
    assignedToId?: number;

    [key: string]: any;
}

export class ProductInstanceParams implements IProductInstanceParams {
    productId!: number;
    basePrice!: number;
    discount?: number;
    details?: string;

    constructor(data?: IProductInstanceParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.basePrice = _data["basePrice"];
            this.discount = _data["discount"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): ProductInstanceParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstanceParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["basePrice"] = this.basePrice;
        data["discount"] = this.discount;
        data["details"] = this.details;
        return data;
    }
}

export interface IProductInstanceParams {
    productId: number;
    basePrice: number;
    discount?: number;
    details?: string;
}

/** Make all properties in T optional */
export class Partial_ProductInstanceParams_ implements IPartial_ProductInstanceParams_ {
    productId?: number;
    basePrice?: number;
    discount?: number;
    details?: string;

    [key: string]: any;

    constructor(data?: IPartial_ProductInstanceParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productId = _data["productId"];
            this.basePrice = _data["basePrice"];
            this.discount = _data["discount"];
            this.details = _data["details"];
        }
    }

    static fromJS(data: any): Partial_ProductInstanceParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ProductInstanceParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productId"] = this.productId;
        data["basePrice"] = this.basePrice;
        data["discount"] = this.discount;
        data["details"] = this.details;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_ProductInstanceParams_ {
    productId?: number;
    basePrice?: number;
    discount?: number;
    details?: string;

    [key: string]: any;
}

export class ProductInstanceStatusParams implements IProductInstanceStatusParams {
    description!: string;
    subType!: ProductInstanceStatus;

    constructor(data?: IProductInstanceStatusParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): ProductInstanceStatusParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstanceStatusParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["subType"] = this.subType;
        return data;
    }
}

export interface IProductInstanceStatusParams {
    description: string;
    subType: ProductInstanceStatus;
}

export enum Language {
    DUTCH = "DUTCH",
    ENGLISH = "ENGLISH",
}

export enum ContractType {
    CONTRACT = "CONTRACT",
    PROPOSAL = "PROPOSAL",
}

export enum ReturnFileType {
    PDF = "PDF",
    TEX = "TEX",
}

export class GenerateContractParams implements IGenerateContractParams {
    name?: string;
    createdAt?: Date;
    language!: Language;
    contentType!: ContractType;
    fileType!: ReturnFileType;
    showDiscountPercentages!: boolean;
    saveToDisk!: boolean;
    signee1Id!: number;
    signee2Id!: number;
    recipientId!: number;

    constructor(data?: IGenerateContractParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.language = _data["language"];
            this.contentType = _data["contentType"];
            this.fileType = _data["fileType"];
            this.showDiscountPercentages = _data["showDiscountPercentages"];
            this.saveToDisk = _data["saveToDisk"];
            this.signee1Id = _data["signee1Id"];
            this.signee2Id = _data["signee2Id"];
            this.recipientId = _data["recipientId"];
        }
    }

    static fromJS(data: any): GenerateContractParams {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateContractParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["language"] = this.language;
        data["contentType"] = this.contentType;
        data["fileType"] = this.fileType;
        data["showDiscountPercentages"] = this.showDiscountPercentages;
        data["saveToDisk"] = this.saveToDisk;
        data["signee1Id"] = this.signee1Id;
        data["signee2Id"] = this.signee2Id;
        data["recipientId"] = this.recipientId;
        return data;
    }
}

export interface IGenerateContractParams {
    name?: string;
    createdAt?: Date;
    language: Language;
    contentType: ContractType;
    fileType: ReturnFileType;
    showDiscountPercentages: boolean;
    saveToDisk: boolean;
    signee1Id: number;
    signee2Id: number;
    recipientId: number;
}

export class ContractStatusParams implements IContractStatusParams {
    description!: string;
    subType!: ContractStatus;

    constructor(data?: IContractStatusParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): ContractStatusParams {
        data = typeof data === 'object' ? data : {};
        let result = new ContractStatusParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["subType"] = this.subType;
        return data;
    }
}

export interface IContractStatusParams {
    description: string;
    subType: ContractStatus;
}

export class InvoiceListResponse implements IInvoiceListResponse {
    list!: Invoice[];
    count!: number;
    lastSeen?: Date;

    constructor(data?: IInvoiceListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Invoice.fromJS(item));
            }
            this.count = _data["count"];
            this.lastSeen = _data["lastSeen"] ? new Date(_data["lastSeen"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InvoiceListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["lastSeen"] = this.lastSeen ? this.lastSeen.toISOString() : <any>undefined;
        return data;
    }
}

export interface IInvoiceListResponse {
    list: Invoice[];
    count: number;
    lastSeen?: Date;
}

export class InvoiceSummary implements IInvoiceSummary {
    id!: number;
    title!: string;
    companyId!: number;
    value!: number;
    status!: InvoiceStatus;

    constructor(data?: IInvoiceSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.value = _data["value"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): InvoiceSummary {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["value"] = this.value;
        data["status"] = this.status;
        return data;
    }
}

export interface IInvoiceSummary {
    id: number;
    title: string;
    companyId: number;
    value: number;
    status: InvoiceStatus;
}

export class ExpiredInvoice implements IExpiredInvoice {
    id!: number;
    version!: number;
    startDate!: Date;
    companyId!: number;
    assignedToId!: number;
    createdAt!: Date;
    updatedAt!: Date;
    createdById!: number;
    value!: number;

    constructor(data?: IExpiredInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.assignedToId = _data["assignedToId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ExpiredInvoice {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiredInvoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["assignedToId"] = this.assignedToId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["value"] = this.value;
        return data;
    }
}

export interface IExpiredInvoice {
    id: number;
    version: number;
    startDate: Date;
    companyId: number;
    assignedToId: number;
    createdAt: Date;
    updatedAt: Date;
    createdById: number;
    value: number;
}

export class InvoiceCreateParams implements IInvoiceCreateParams {
    title!: string;
    poNumber?: string;
    comments?: string;
    startDate?: Date;
    assignedToId?: number;
    productInstanceIds!: number[];
    companyId!: number;

    constructor(data?: IInvoiceCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.productInstanceIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.poNumber = _data["poNumber"];
            this.comments = _data["comments"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.assignedToId = _data["assignedToId"];
            if (Array.isArray(_data["productInstanceIds"])) {
                this.productInstanceIds = [] as any;
                for (let item of _data["productInstanceIds"])
                    this.productInstanceIds!.push(item);
            }
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): InvoiceCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["poNumber"] = this.poNumber;
        data["comments"] = this.comments;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["assignedToId"] = this.assignedToId;
        if (Array.isArray(this.productInstanceIds)) {
            data["productInstanceIds"] = [];
            for (let item of this.productInstanceIds)
                data["productInstanceIds"].push(item);
        }
        data["companyId"] = this.companyId;
        return data;
    }
}

export interface IInvoiceCreateParams {
    title: string;
    poNumber?: string;
    comments?: string;
    startDate?: Date;
    assignedToId?: number;
    productInstanceIds: number[];
    companyId: number;
}

/** Make all properties in T optional */
export class Partial_InvoiceParams_ implements IPartial_InvoiceParams_ {
    title?: string;
    poNumber?: string;
    comments?: string;
    startDate?: Date;
    assignedToId?: number;

    [key: string]: any;

    constructor(data?: IPartial_InvoiceParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.title = _data["title"];
            this.poNumber = _data["poNumber"];
            this.comments = _data["comments"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.assignedToId = _data["assignedToId"];
        }
    }

    static fromJS(data: any): Partial_InvoiceParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_InvoiceParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["title"] = this.title;
        data["poNumber"] = this.poNumber;
        data["comments"] = this.comments;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["assignedToId"] = this.assignedToId;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_InvoiceParams_ {
    title?: string;
    poNumber?: string;
    comments?: string;
    startDate?: Date;
    assignedToId?: number;

    [key: string]: any;
}

export class GenerateInvoiceParams implements IGenerateInvoiceParams {
    name?: string;
    createdAt?: Date;
    language!: Language;
    fileType!: ReturnFileType;
    showDiscountPercentages!: boolean;
    saveToDisk!: boolean;
    recipientId!: number;

    constructor(data?: IGenerateInvoiceParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.language = _data["language"];
            this.fileType = _data["fileType"];
            this.showDiscountPercentages = _data["showDiscountPercentages"];
            this.saveToDisk = _data["saveToDisk"];
            this.recipientId = _data["recipientId"];
        }
    }

    static fromJS(data: any): GenerateInvoiceParams {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateInvoiceParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["language"] = this.language;
        data["fileType"] = this.fileType;
        data["showDiscountPercentages"] = this.showDiscountPercentages;
        data["saveToDisk"] = this.saveToDisk;
        data["recipientId"] = this.recipientId;
        return data;
    }
}

export interface IGenerateInvoiceParams {
    name?: string;
    createdAt?: Date;
    language: Language;
    fileType: ReturnFileType;
    showDiscountPercentages: boolean;
    saveToDisk: boolean;
    recipientId: number;
}

export class CustomRecipient implements ICustomRecipient {
    number!: string;
    name!: string;
    organizationName?: string;
    street?: string;
    postalCode?: string;
    city?: string;
    country?: string;

    constructor(data?: ICustomRecipient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.name = _data["name"];
            this.organizationName = _data["organizationName"];
            this.street = _data["street"];
            this.postalCode = _data["postalCode"];
            this.city = _data["city"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): CustomRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new CustomRecipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["name"] = this.name;
        data["organizationName"] = this.organizationName;
        data["street"] = this.street;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["country"] = this.country;
        return data;
    }
}

export interface ICustomRecipient {
    number: string;
    name: string;
    organizationName?: string;
    street?: string;
    postalCode?: string;
    city?: string;
    country?: string;
}

export class CustomProduct implements ICustomProduct {
    name!: string;
    amount!: number;
    pricePerOne!: number;
    valueAddedTax!: VAT;

    constructor(data?: ICustomProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.amount = _data["amount"];
            this.pricePerOne = _data["pricePerOne"];
            this.valueAddedTax = _data["valueAddedTax"];
        }
    }

    static fromJS(data: any): CustomProduct {
        data = typeof data === 'object' ? data : {};
        let result = new CustomProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["amount"] = this.amount;
        data["pricePerOne"] = this.pricePerOne;
        data["valueAddedTax"] = this.valueAddedTax;
        return data;
    }
}

export interface ICustomProduct {
    name: string;
    amount: number;
    pricePerOne: number;
    valueAddedTax: VAT;
}

export class CustomInvoiceGenSettings implements ICustomInvoiceGenSettings {
    language!: Language;
    fileType!: ReturnFileType;
    recipient!: CustomRecipient;
    subject!: string;
    ourReference!: string;
    theirReference?: string;
    products!: CustomProduct[];
    date!: Date;

    constructor(data?: ICustomInvoiceGenSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.recipient = new CustomRecipient();
            this.products = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"];
            this.fileType = _data["fileType"];
            this.recipient = _data["recipient"] ? CustomRecipient.fromJS(_data["recipient"]) : new CustomRecipient();
            this.subject = _data["subject"];
            this.ourReference = _data["ourReference"];
            this.theirReference = _data["theirReference"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(CustomProduct.fromJS(item));
            }
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomInvoiceGenSettings {
        data = typeof data === 'object' ? data : {};
        let result = new CustomInvoiceGenSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        data["fileType"] = this.fileType;
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["subject"] = this.subject;
        data["ourReference"] = this.ourReference;
        data["theirReference"] = this.theirReference;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICustomInvoiceGenSettings {
    language: Language;
    fileType: ReturnFileType;
    recipient: CustomRecipient;
    subject: string;
    ourReference: string;
    theirReference?: string;
    products: CustomProduct[];
    date: Date;
}

export class InvoiceStatusParams implements IInvoiceStatusParams {
    description!: string;
    subType!: InvoiceStatus;

    constructor(data?: IInvoiceStatusParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): InvoiceStatusParams {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceStatusParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["subType"] = this.subType;
        return data;
    }
}

export interface IInvoiceStatusParams {
    description: string;
    subType: InvoiceStatus;
}

export class CategoryListResponse implements ICategoryListResponse {
    list!: ProductCategory[];
    count!: number;

    constructor(data?: ICategoryListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(ProductCategory.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): CategoryListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface ICategoryListResponse {
    list: ProductCategory[];
    count: number;
}

export class CategorySummary implements ICategorySummary {
    id!: number;
    name!: string;

    constructor(data?: ICategorySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategorySummary {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICategorySummary {
    id: number;
    name: string;
}

export class CategoryParams implements ICategoryParams {
    name!: string;

    constructor(data?: ICategoryParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryParams {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICategoryParams {
    name: string;
}

/** Make all properties in T optional */
export class Partial_CategoryParams_ implements IPartial_CategoryParams_ {
    name?: string;

    [key: string]: any;

    constructor(data?: IPartial_CategoryParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Partial_CategoryParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_CategoryParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_CategoryParams_ {
    name?: string;

    [key: string]: any;
}

export class ProductListResponse implements IProductListResponse {
    list!: Product[];
    count!: number;

    constructor(data?: IProductListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Product.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ProductListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IProductListResponse {
    list: Product[];
    count: number;
}

export class ProductSummary implements IProductSummary {
    id!: number;
    vatId!: number;
    nameDutch!: string;
    nameEnglish!: string;
    targetPrice!: number;
    status!: ProductStatus;

    constructor(data?: IProductSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vatId = _data["vatId"];
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ProductSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vatId"] = this.vatId;
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        data["status"] = this.status;
        return data;
    }
}

export interface IProductSummary {
    id: number;
    vatId: number;
    nameDutch: string;
    nameEnglish: string;
    targetPrice: number;
    status: ProductStatus;
}

export class ProductParams implements IProductParams {
    nameDutch!: string;
    nameEnglish!: string;
    targetPrice!: number;
    minTarget?: number;
    maxTarget?: number;
    status!: ProductStatus;
    description?: string;
    vatId!: number;
    categoryId!: number;
    contractTextDutch!: string;
    contractTextEnglish!: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;

    constructor(data?: IProductParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
            this.minTarget = _data["minTarget"];
            this.maxTarget = _data["maxTarget"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.vatId = _data["vatId"];
            this.categoryId = _data["categoryId"];
            this.contractTextDutch = _data["contractTextDutch"];
            this.contractTextEnglish = _data["contractTextEnglish"];
            this.deliverySpecificationDutch = _data["deliverySpecificationDutch"];
            this.deliverySpecificationEnglish = _data["deliverySpecificationEnglish"];
        }
    }

    static fromJS(data: any): ProductParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProductParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        data["minTarget"] = this.minTarget;
        data["maxTarget"] = this.maxTarget;
        data["status"] = this.status;
        data["description"] = this.description;
        data["vatId"] = this.vatId;
        data["categoryId"] = this.categoryId;
        data["contractTextDutch"] = this.contractTextDutch;
        data["contractTextEnglish"] = this.contractTextEnglish;
        data["deliverySpecificationDutch"] = this.deliverySpecificationDutch;
        data["deliverySpecificationEnglish"] = this.deliverySpecificationEnglish;
        return data;
    }
}

export interface IProductParams {
    nameDutch: string;
    nameEnglish: string;
    targetPrice: number;
    minTarget?: number;
    maxTarget?: number;
    status: ProductStatus;
    description?: string;
    vatId: number;
    categoryId: number;
    contractTextDutch: string;
    contractTextEnglish: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;
}

/** Make all properties in T optional */
export class Partial_ProductParams_ implements IPartial_ProductParams_ {
    nameDutch?: string;
    nameEnglish?: string;
    targetPrice?: number;
    minTarget?: number;
    maxTarget?: number;
    status?: ProductStatus;
    description?: string;
    vatId?: number;
    categoryId?: number;
    contractTextDutch?: string;
    contractTextEnglish?: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;

    [key: string]: any;

    constructor(data?: IPartial_ProductParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
            this.minTarget = _data["minTarget"];
            this.maxTarget = _data["maxTarget"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.vatId = _data["vatId"];
            this.categoryId = _data["categoryId"];
            this.contractTextDutch = _data["contractTextDutch"];
            this.contractTextEnglish = _data["contractTextEnglish"];
            this.deliverySpecificationDutch = _data["deliverySpecificationDutch"];
            this.deliverySpecificationEnglish = _data["deliverySpecificationEnglish"];
        }
    }

    static fromJS(data: any): Partial_ProductParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ProductParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        data["minTarget"] = this.minTarget;
        data["maxTarget"] = this.maxTarget;
        data["status"] = this.status;
        data["description"] = this.description;
        data["vatId"] = this.vatId;
        data["categoryId"] = this.categoryId;
        data["contractTextDutch"] = this.contractTextDutch;
        data["contractTextEnglish"] = this.contractTextEnglish;
        data["deliverySpecificationDutch"] = this.deliverySpecificationDutch;
        data["deliverySpecificationEnglish"] = this.deliverySpecificationEnglish;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_ProductParams_ {
    nameDutch?: string;
    nameEnglish?: string;
    targetPrice?: number;
    minTarget?: number;
    maxTarget?: number;
    status?: ProductStatus;
    description?: string;
    vatId?: number;
    categoryId?: number;
    contractTextDutch?: string;
    contractTextEnglish?: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;

    [key: string]: any;
}

/** Make all properties in T optional */
export class Partial_PricingParams_ implements IPartial_PricingParams_ {
    description?: string;
    data?: string[][];

    [key: string]: any;

    constructor(data?: IPartial_PricingParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): Partial_PricingParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_PricingParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_PricingParams_ {
    description?: string;
    data?: string[][];

    [key: string]: any;
}

export class ProductInstanceListResponse implements IProductInstanceListResponse {
    list!: ProductInstance[];
    count!: number;

    constructor(data?: IProductInstanceListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(ProductInstance.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ProductInstanceListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstanceListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IProductInstanceListResponse {
    list: ProductInstance[];
    count: number;
}

export class PaginationParams implements IPaginationParams {
    skip?: number;
    take?: number;

    constructor(data?: IPaginationParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PaginationParams {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IPaginationParams {
    skip?: number;
    take?: number;
}

export class AnalysisResultByYear implements IAnalysisResultByYear {
    amount!: number;
    nrOfProducts!: number;
    year!: number;

    constructor(data?: IAnalysisResultByYear) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.nrOfProducts = _data["nrOfProducts"];
            this.year = _data["year"];
        }
    }

    static fromJS(data: any): AnalysisResultByYear {
        data = typeof data === 'object' ? data : {};
        let result = new AnalysisResultByYear();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["nrOfProducts"] = this.nrOfProducts;
        data["year"] = this.year;
        return data;
    }
}

export interface IAnalysisResultByYear {
    amount: number;
    nrOfProducts: number;
    year: number;
}

export class AnalysisResult implements IAnalysisResult {
    amount!: number;
    nrOfProducts!: number;

    constructor(data?: IAnalysisResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.nrOfProducts = _data["nrOfProducts"];
        }
    }

    static fromJS(data: any): AnalysisResult {
        data = typeof data === 'object' ? data : {};
        let result = new AnalysisResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["nrOfProducts"] = this.nrOfProducts;
        return data;
    }
}

export interface IAnalysisResult {
    amount: number;
    nrOfProducts: number;
}

export class InvoicedAmounts implements IInvoicedAmounts {
    delivered!: AnalysisResult;
    notDelivered!: AnalysisResult;

    constructor(data?: IInvoicedAmounts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.delivered = new AnalysisResult();
            this.notDelivered = new AnalysisResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.delivered = _data["delivered"] ? AnalysisResult.fromJS(_data["delivered"]) : new AnalysisResult();
            this.notDelivered = _data["notDelivered"] ? AnalysisResult.fromJS(_data["notDelivered"]) : new AnalysisResult();
        }
    }

    static fromJS(data: any): InvoicedAmounts {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicedAmounts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["delivered"] = this.delivered ? this.delivered.toJSON() : <any>undefined;
        data["notDelivered"] = this.notDelivered ? this.notDelivered.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInvoicedAmounts {
    delivered: AnalysisResult;
    notDelivered: AnalysisResult;
}

export class DashboardProductInstanceStats implements IDashboardProductInstanceStats {
    suggested!: AnalysisResult;
    contracted!: AnalysisResult;
    delivered!: AnalysisResult;
    invoiced!: InvoicedAmounts;
    paid!: AnalysisResult;
    financialYears!: number[];

    constructor(data?: IDashboardProductInstanceStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.suggested = new AnalysisResult();
            this.contracted = new AnalysisResult();
            this.delivered = new AnalysisResult();
            this.invoiced = new InvoicedAmounts();
            this.paid = new AnalysisResult();
            this.financialYears = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.suggested = _data["suggested"] ? AnalysisResult.fromJS(_data["suggested"]) : new AnalysisResult();
            this.contracted = _data["contracted"] ? AnalysisResult.fromJS(_data["contracted"]) : new AnalysisResult();
            this.delivered = _data["delivered"] ? AnalysisResult.fromJS(_data["delivered"]) : new AnalysisResult();
            this.invoiced = _data["invoiced"] ? InvoicedAmounts.fromJS(_data["invoiced"]) : new InvoicedAmounts();
            this.paid = _data["paid"] ? AnalysisResult.fromJS(_data["paid"]) : new AnalysisResult();
            if (Array.isArray(_data["financialYears"])) {
                this.financialYears = [] as any;
                for (let item of _data["financialYears"])
                    this.financialYears!.push(item);
            }
        }
    }

    static fromJS(data: any): DashboardProductInstanceStats {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardProductInstanceStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["suggested"] = this.suggested ? this.suggested.toJSON() : <any>undefined;
        data["contracted"] = this.contracted ? this.contracted.toJSON() : <any>undefined;
        data["delivered"] = this.delivered ? this.delivered.toJSON() : <any>undefined;
        data["invoiced"] = this.invoiced ? this.invoiced.toJSON() : <any>undefined;
        data["paid"] = this.paid ? this.paid.toJSON() : <any>undefined;
        if (Array.isArray(this.financialYears)) {
            data["financialYears"] = [];
            for (let item of this.financialYears)
                data["financialYears"].push(item);
        }
        return data;
    }
}

export interface IDashboardProductInstanceStats {
    suggested: AnalysisResult;
    contracted: AnalysisResult;
    delivered: AnalysisResult;
    invoiced: InvoicedAmounts;
    paid: AnalysisResult;
    financialYears: number[];
}

/** Make all properties in T optional */
export class Partial_RoleParams_ implements IPartial_RoleParams_ {
    ldapGroup?: string;

    [key: string]: any;

    constructor(data?: IPartial_RoleParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.ldapGroup = _data["ldapGroup"];
        }
    }

    static fromJS(data: any): Partial_RoleParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_RoleParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["ldapGroup"] = this.ldapGroup;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_RoleParams_ {
    ldapGroup?: string;

    [key: string]: any;
}

export enum Roles {
    SIGNEE = "SIGNEE",
    FINANCIAL = "FINANCIAL",
    ADMIN = "ADMIN",
    GENERAL = "GENERAL",
    AUDIT = "AUDIT",
}

export class UserParams implements IUserParams {
    email!: string;
    firstName!: string;
    lastNamePreposition?: string;
    lastName!: string;
    function!: string;
    gender!: Gender;
    replyToEmail?: string;
    receiveEmails?: boolean;
    sendEmailsToReplyToEmail?: boolean;
    comment?: string;
    ldapOverrideEmail?: boolean;
    roles?: Roles[];

    constructor(data?: IUserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.function = _data["function"];
            this.gender = _data["gender"];
            this.replyToEmail = _data["replyToEmail"];
            this.receiveEmails = _data["receiveEmails"];
            this.sendEmailsToReplyToEmail = _data["sendEmailsToReplyToEmail"];
            this.comment = _data["comment"];
            this.ldapOverrideEmail = _data["ldapOverrideEmail"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserParams {
        data = typeof data === 'object' ? data : {};
        let result = new UserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["function"] = this.function;
        data["gender"] = this.gender;
        data["replyToEmail"] = this.replyToEmail;
        data["receiveEmails"] = this.receiveEmails;
        data["sendEmailsToReplyToEmail"] = this.sendEmailsToReplyToEmail;
        data["comment"] = this.comment;
        data["ldapOverrideEmail"] = this.ldapOverrideEmail;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserParams {
    email: string;
    firstName: string;
    lastNamePreposition?: string;
    lastName: string;
    function: string;
    gender: Gender;
    replyToEmail?: string;
    receiveEmails?: boolean;
    sendEmailsToReplyToEmail?: boolean;
    comment?: string;
    ldapOverrideEmail?: boolean;
    roles?: Roles[];
}

export class SetupParams implements ISetupParams {
    admin!: UserParams;

    constructor(data?: ISetupParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.admin = new UserParams();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.admin = _data["admin"] ? UserParams.fromJS(_data["admin"]) : new UserParams();
        }
    }

    static fromJS(data: any): SetupParams {
        data = typeof data === 'object' ? data : {};
        let result = new SetupParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["admin"] = this.admin ? this.admin.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISetupParams {
    admin: UserParams;
}

export class AuthStatus implements IAuthStatus {
    authenticated!: boolean;

    constructor(data?: IAuthStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticated = _data["authenticated"];
        }
    }

    static fromJS(data: any): AuthStatus {
        data = typeof data === 'object' ? data : {};
        let result = new AuthStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticated"] = this.authenticated;
        return data;
    }
}

export interface IAuthStatus {
    authenticated: boolean;
}

export class Profile implements IProfile {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Gender of this user */
    gender!: Gender;
    /** First name of this user */
    firstName!: string;
    /** Middle name of this user, if he/she has any */
    lastNamePreposition!: string;
    /** Last name of this user */
    lastName!: string;
    /** Email address of the user */
    email!: string;
    /** Email address used in PDF files */
    replyToEmail!: string;
    /** Any comments regarding this user */
    comment!: string;
    /** Function of this user, used when generating documents and printed below this user's name */
    function!: string;
    /** Optional filename of the user's avatar */
    avatarFilename!: string;
    /** Optional filename of the user's background */
    backgroundFilename!: string;
    /** Whether this user wishes to receive (regular) email updates, e.g. sent invoices */
    receiveEmails!: boolean;
    /** Whether the update emails (from the boolean above) should
be sent to "email", or "replyToEmail" */
    sendEmailsToReplyToEmail!: boolean;
    /** The roles this user has */
    roles!: Role[];
    /** Identity for local login */
    identityLocal?: IdentityLocal;
    /** Identity for LDAP */
    identityLdap?: IdentityLDAP;
    hasApiKey?: boolean;

    constructor(data?: IProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.replyToEmail = _data["replyToEmail"];
            this.comment = _data["comment"];
            this.function = _data["function"];
            this.avatarFilename = _data["avatarFilename"];
            this.backgroundFilename = _data["backgroundFilename"];
            this.receiveEmails = _data["receiveEmails"];
            this.sendEmailsToReplyToEmail = _data["sendEmailsToReplyToEmail"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
            this.identityLocal = _data["identityLocal"] ? IdentityLocal.fromJS(_data["identityLocal"]) : <any>undefined;
            this.identityLdap = _data["identityLdap"] ? IdentityLDAP.fromJS(_data["identityLdap"]) : <any>undefined;
            this.hasApiKey = _data["hasApiKey"];
        }
    }

    static fromJS(data: any): Profile {
        data = typeof data === 'object' ? data : {};
        let result = new Profile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["replyToEmail"] = this.replyToEmail;
        data["comment"] = this.comment;
        data["function"] = this.function;
        data["avatarFilename"] = this.avatarFilename;
        data["backgroundFilename"] = this.backgroundFilename;
        data["receiveEmails"] = this.receiveEmails;
        data["sendEmailsToReplyToEmail"] = this.sendEmailsToReplyToEmail;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["identityLocal"] = this.identityLocal ? this.identityLocal.toJSON() : <any>undefined;
        data["identityLdap"] = this.identityLdap ? this.identityLdap.toJSON() : <any>undefined;
        data["hasApiKey"] = this.hasApiKey;
        return data;
    }
}

export interface IProfile {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Gender of this user */
    gender: Gender;
    /** First name of this user */
    firstName: string;
    /** Middle name of this user, if he/she has any */
    lastNamePreposition: string;
    /** Last name of this user */
    lastName: string;
    /** Email address of the user */
    email: string;
    /** Email address used in PDF files */
    replyToEmail: string;
    /** Any comments regarding this user */
    comment: string;
    /** Function of this user, used when generating documents and printed below this user's name */
    function: string;
    /** Optional filename of the user's avatar */
    avatarFilename: string;
    /** Optional filename of the user's background */
    backgroundFilename: string;
    /** Whether this user wishes to receive (regular) email updates, e.g. sent invoices */
    receiveEmails: boolean;
    /** Whether the update emails (from the boolean above) should
be sent to "email", or "replyToEmail" */
    sendEmailsToReplyToEmail: boolean;
    /** The roles this user has */
    roles: Role[];
    /** Identity for local login */
    identityLocal?: IdentityLocal;
    /** Identity for LDAP */
    identityLdap?: IdentityLDAP;
    hasApiKey?: boolean;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    password!: string;
    repeatPassword!: string;
    token!: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.repeatPassword = _data["repeatPassword"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["repeatPassword"] = this.repeatPassword;
        data["token"] = this.token;
        return data;
    }
}

export interface IResetPasswordRequest {
    password: string;
    repeatPassword: string;
    token: string;
}

export class GeneralPrivateInfo implements IGeneralPrivateInfo {
    financialYears!: number[];

    constructor(data?: IGeneralPrivateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.financialYears = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["financialYears"])) {
                this.financialYears = [] as any;
                for (let item of _data["financialYears"])
                    this.financialYears!.push(item);
            }
        }
    }

    static fromJS(data: any): GeneralPrivateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralPrivateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.financialYears)) {
            data["financialYears"] = [];
            for (let item of this.financialYears)
                data["financialYears"].push(item);
        }
        return data;
    }
}

export interface IGeneralPrivateInfo {
    financialYears: number[];
}

export enum LoginMethods {
    Local = "local",
    Ldap = "ldap",
}

export class GeneralPublicInfo implements IGeneralPublicInfo {
    loginMethod!: LoginMethods;

    constructor(data?: IGeneralPublicInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginMethod = _data["loginMethod"];
        }
    }

    static fromJS(data: any): GeneralPublicInfo {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralPublicInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginMethod"] = this.loginMethod;
        return data;
    }
}

export interface IGeneralPublicInfo {
    loginMethod: LoginMethods;
}

export class UserListResponse implements IUserListResponse {
    list!: User[];
    count!: number;

    constructor(data?: IUserListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(User.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): UserListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IUserListResponse {
    list: User[];
    count: number;
}

export class UserSummary implements IUserSummary {
    id!: number;
    firstName!: string;
    lastNamePreposition!: string;
    lastName!: string;
    email!: string;
    avatarFilename!: string;
    backgroundFilename!: string;
    roles!: Roles[];

    constructor(data?: IUserSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.avatarFilename = _data["avatarFilename"];
            this.backgroundFilename = _data["backgroundFilename"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserSummary {
        data = typeof data === 'object' ? data : {};
        let result = new UserSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["avatarFilename"] = this.avatarFilename;
        data["backgroundFilename"] = this.backgroundFilename;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserSummary {
    id: number;
    firstName: string;
    lastNamePreposition: string;
    lastName: string;
    email: string;
    avatarFilename: string;
    backgroundFilename: string;
    roles: Roles[];
}

/** Make all properties in T optional */
export class Partial_UserParams_ implements IPartial_UserParams_ {
    email?: string;
    firstName?: string;
    lastNamePreposition?: string;
    lastName?: string;
    function?: string;
    gender?: Gender;
    replyToEmail?: string;
    receiveEmails?: boolean;
    sendEmailsToReplyToEmail?: boolean;
    comment?: string;
    ldapOverrideEmail?: boolean;
    roles?: Roles[];

    [key: string]: any;

    constructor(data?: IPartial_UserParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.function = _data["function"];
            this.gender = _data["gender"];
            this.replyToEmail = _data["replyToEmail"];
            this.receiveEmails = _data["receiveEmails"];
            this.sendEmailsToReplyToEmail = _data["sendEmailsToReplyToEmail"];
            this.comment = _data["comment"];
            this.ldapOverrideEmail = _data["ldapOverrideEmail"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): Partial_UserParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_UserParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["function"] = this.function;
        data["gender"] = this.gender;
        data["replyToEmail"] = this.replyToEmail;
        data["receiveEmails"] = this.receiveEmails;
        data["sendEmailsToReplyToEmail"] = this.sendEmailsToReplyToEmail;
        data["comment"] = this.comment;
        data["ldapOverrideEmail"] = this.ldapOverrideEmail;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_UserParams_ {
    email?: string;
    firstName?: string;
    lastNamePreposition?: string;
    lastName?: string;
    function?: string;
    gender?: Gender;
    replyToEmail?: string;
    receiveEmails?: boolean;
    sendEmailsToReplyToEmail?: boolean;
    comment?: string;
    ldapOverrideEmail?: boolean;
    roles?: Roles[];

    [key: string]: any;
}

export class TransferUserParams implements ITransferUserParams {
    toUserId!: number;

    constructor(data?: ITransferUserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.toUserId = _data["toUserId"];
        }
    }

    static fromJS(data: any): TransferUserParams {
        data = typeof data === 'object' ? data : {};
        let result = new TransferUserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["toUserId"] = this.toUserId;
        return data;
    }
}

export interface ITransferUserParams {
    toUserId: number;
}

export class LdapIdentityParams implements ILdapIdentityParams {
    username!: string;

    constructor(data?: ILdapIdentityParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): LdapIdentityParams {
        data = typeof data === 'object' ? data : {};
        let result = new LdapIdentityParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        return data;
    }
}

export interface ILdapIdentityParams {
    username: string;
}

/** Make all properties in T optional */
export class Partial_LdapIdentityParams_ implements IPartial_LdapIdentityParams_ {
    username?: string;

    [key: string]: any;

    constructor(data?: IPartial_LdapIdentityParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): Partial_LdapIdentityParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_LdapIdentityParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["username"] = this.username;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_LdapIdentityParams_ {
    username?: string;

    [key: string]: any;
}

export class VATListResponse implements IVATListResponse {
    list!: ValueAddedTax[];
    count!: number;

    constructor(data?: IVATListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(ValueAddedTax.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): VATListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VATListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IVATListResponse {
    list: ValueAddedTax[];
    count: number;
}

export class VATSummary implements IVATSummary {
    id!: number;
    amount!: number;

    constructor(data?: IVATSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): VATSummary {
        data = typeof data === 'object' ? data : {};
        let result = new VATSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IVATSummary {
    id: number;
    amount: number;
}

/** Make all properties in T optional */
export class Partial_VATParams_ implements IPartial_VATParams_ {
    category?: VAT;
    amount?: number;

    [key: string]: any;

    constructor(data?: IPartial_VATParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.category = _data["category"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): Partial_VATParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_VATParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["category"] = this.category;
        data["amount"] = this.amount;
        return data;
    }
}

/** Make all properties in T optional */
export interface IPartial_VATParams_ {
    category?: VAT;
    amount?: number;

    [key: string]: any;
}

export class LoginParams implements ILoginParams {
    email?: string;
    password?: string;
    rememberMe?: boolean;

    constructor(data?: ILoginParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginParams {
        data = typeof data === 'object' ? data : {};
        let result = new LoginParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginParams {
    email?: string;
    password?: string;
    rememberMe?: boolean;
}

export class LDAPLoginParams implements ILDAPLoginParams {
    username?: string;
    password?: string;
    rememberMe?: boolean;

    constructor(data?: ILDAPLoginParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LDAPLoginParams {
        data = typeof data === 'object' ? data : {};
        let result = new LDAPLoginParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILDAPLoginParams {
    username?: string;
    password?: string;
    rememberMe?: boolean;
}

export class Body implements IBody {
    productId!: number;

    [key: string]: any;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productId"] = this.productId;
        return data;
    }
}

export interface IBody {
    productId: number;

    [key: string]: any;
}

export class Extra implements IExtra {
    nrOfProducts!: number;
    sumProducts!: number;

    [key: string]: any;

    constructor(data?: IExtra) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nrOfProducts = _data["nrOfProducts"];
            this.sumProducts = _data["sumProducts"];
        }
    }

    static fromJS(data: any): Extra {
        data = typeof data === 'object' ? data : {};
        let result = new Extra();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nrOfProducts"] = this.nrOfProducts;
        data["sumProducts"] = this.sumProducts;
        return data;
    }
}

export interface IExtra {
    nrOfProducts: number;
    sumProducts: number;

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}